<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>LuckyDog | CSUwangj&#x27;s Blog - fuck</title>
	<link href="https://CSUwangj.github.io/tags/fuck/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://CSUwangj.github.io/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2020-08-07T02:01:26.830854+08:00</updated>
	<id>https://CSUwangj.github.io/tags/fuck/atom.xml</id>
	<entry xml:lang="en">
		<title>How to recover DES master key from round key</title>
		<published>2019-11-09T22:13:16+08:00</published>
		<updated>2020-08-07T02:01:26.830854+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/how-to-recover-des-master-key-from-round-key/" type="text/html"/>
		<id>https://CSUwangj.github.io/how-to-recover-des-master-key-from-round-key/</id>
		<content type="html">&lt;p&gt;$1# TLDR&lt;&#x2F;p&gt;
&lt;p&gt;Reverse the picking(or called compressing) process where extract round key from part of master key to get most of master key(56bits), use parity to recover last 8bits.&lt;&#x2F;p&gt;
&lt;p&gt;If the dumbass&#x2F;fuckhead&#x2F;shithead who created this question forgot or not known parity, just fuck it.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;we-got-the-key&quot;&gt;We Got the Key!&lt;&#x2F;h1&gt;
&lt;p&gt;I came across this problem when I participated in one shity CTF.&lt;&#x2F;p&gt;
&lt;p&gt;Here goes problem:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import pyDes
import base64
deskey = &amp;quot;********&amp;quot;
DES = pyDes.des(deskey)
DES.setMode(&amp;#x27;ECB&amp;#x27;)
DES.Kn = [
			[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],
			[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], 
			[0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0],
			[1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], 
			[0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
			[0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],
			[0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
			[0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],
			[0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],
			[0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0],
			[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1],
			[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0],
			[1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0],
			[1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1],
			[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1],
			[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1]
		]
#cipher_list = base64.b64encode(DES.encrypt(mes))
cipher_list= &amp;quot;gAN5RT1XWKI0OyUayZj35SlKQ+if2PAJ&amp;quot;
#flag = mes+deskey
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I checked &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;twhiteman&#x2F;pyDes&#x2F;blob&#x2F;master&#x2F;pyDes.py&quot;&gt;pyDes&lt;&#x2F;a&gt; and found it a normal implementation, so problem is easy, add one more line to decrypt the cipher, recover master key from round keys.&lt;&#x2F;p&gt;
&lt;p&gt;So we don&#x27;t have to care about how DES encrypt data, but how these round key are generated.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;des-key-schedule&quot;&gt;DES key schedule&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;drop-parity&quot;&gt;drop parity&lt;&#x2F;h2&gt;
&lt;p&gt;Firstly, we have 64 bits key, every byte should have odd parity.&lt;&#x2F;p&gt;
&lt;p&gt;So we would let key go through permuted choice one, where we drop 8th bit of every byte.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;key = [0] * 64 # 64bit key
pc1 = [
  56, 48, 40, 32, 24, 16,  8,
  0, 57, 49, 41, 33, 25, 17,
  9,  1, 58, 50, 42, 34, 26,
 18, 10,  2, 59, 51, 43, 35,
 62, 54, 46, 38, 30, 22, 14,
  6, 61, 53, 45, 37, 29, 21,
 13,  5, 60, 52, 44, 36, 28,
 20, 12,  4, 27, 19, 11,  3
]
mid_key = list(map(lambda x: key[x], pc1))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;derive-round-key&quot;&gt;derive round key&lt;&#x2F;h2&gt;
&lt;p&gt;We chopped mid key into two even part, every round left shift it and let it go through permuted choice two, which compress 56 bit into 48 bit.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;left_rotations = [
    1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
]
pc2 = [
	13, 16, 10, 23,  0,  4,
	 2, 27, 14,  5, 20,  9,
	22, 18, 11,  3, 25,  7,
	15,  6, 26, 19, 12,  1,
	40, 51, 30, 36, 46, 54,
	29, 39, 50, 44, 32, 47,
	43, 48, 38, 55, 33, 52,
	45, 41, 49, 35, 28, 31
]

L = mid_key[:28]
R = mid_key[28:]

round_key = []

for i in range(len(left_rotation)):
    for j in range(left_rotation[i]):
        L = L[1:] + L[:1]
        R = R[1:] + R[:1]
    round_key.append(list(map(lambda x: (L+R)[x], pc2)))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;reverse-it&quot;&gt;Reverse it&lt;&#x2F;h1&gt;
&lt;p&gt;We could get only 48 out of 56 bits, does it mean that we need to use brute force to get last 8 bits?&lt;&#x2F;p&gt;
&lt;p&gt;Off course not! We got 16 round keys, Which means we actually got every bit of 56-bit-key.&lt;&#x2F;p&gt;
&lt;p&gt;We just need rerun the key assign process, to a opposite direction.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# Extract part of master key from round key
mid_key = [-1] * 56 # -1 for key not appeared
for i in range(len(left_rotation)):
  for j in range(left_rotation[i]):
    mid_key = mid_key[1:28] + mid_key[:1] + mid_key[29:] + mid_key[28:29]
  for k in range(len(pc2)):
    if mid_key[pc2[k]] != -1 and mid_key[pc2[k]] != round_key[i][k]:
      print(&amp;quot;This should not happen!&amp;quot;)
    mid_key[pc2[k]] = round_key[i][k]

# Reverse permute process of dropping parity

key = [-1] * 64
for i in range(len(pc1)):
  key[pc1[i]] = mid_key[i]

# Recover master key according to parity
for i in range(8):
  sum = 0
  for j in range(7):
    sum += key[i*8+j]
  key[i*8+7] = 1 - sum % 2

# Print key ascii
print(&amp;#x27;&amp;#x27;.join([chr(int(key[i:i+8],2)) for i in range(0, len(key), 8)]))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
</feed>
