<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>LuckyDog | CSUwangj&#x27;s Blog - ACM</title>
	<link href="https://CSUwangj.github.io/tags/ACM/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://CSUwangj.github.io/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2020-08-07T01:54:42.988741+08:00</updated>
	<id>https://CSUwangj.github.io/tags/ACM/atom.xml</id>
	<entry xml:lang="en">
		<title>ACM中一些常见的问题及原因</title>
		<published>2019-01-30T17:23:34+08:00</published>
		<updated>2020-08-07T01:54:42.988741+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin/" type="text/html"/>
		<id>https://CSUwangj.github.io/acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin/</id>
		<content type="html">&lt;p&gt;最近在 ACM 群灌水，顺便解决了一点问题，感觉可能会成为日经系列，寻思可以写个博文专门写写，正好也是对自己学习知识的检验。&lt;&#x2F;p&gt;
&lt;p&gt;我觉得这篇文章阅读方式可以按照《C语言常见问题集》，遇到问题了来看看也行，电脑阅读的时候右边应该会有个目录可以跳转，顺着读一遍也行。&lt;&#x2F;p&gt;
&lt;p&gt;文章只能慢慢更新，因为我并不想随意地对待这种难得的问题，然而工作在身并不能全身心投入。&lt;&#x2F;p&gt;
&lt;p&gt;以下内容如无特殊声明，采用C99和C++11标准。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;wei-shi-yao-zai-du-ru-de-shi-hou-bu-jia-jing-chang-hui-re-dan-shi-shu-zu-ming-bu-jia-jiu-mei-wen-ti&quot;&gt;为什么在读入的时候不加&amp;amp;经常会RE，但是数组名不加&amp;amp;就没问题？&lt;&#x2F;h1&gt;
&lt;p&gt;我们直接来看一段代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int a;
    scanf(&amp;quot;%d&amp;quot;, a);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译运行的结果基本是&lt;code&gt;Segmentation fault (core dumped)&lt;&#x2F;code&gt;，如果是在windows上用codeblocks、devcpp之类的写的程序，多半会看到&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;1573525655820.png&quot; alt=&quot;1573525460495 %}或者{% asset_img 1573526342103.png 1573526342103 %}如果是devcpp，还可能是在一段时间的无响应后退出，同时返回值是一个大得惊人的数字{% asset_img 1573525655820.png 1573525655820&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这里我们需要对比一下&lt;code&gt;a&lt;&#x2F;code&gt;和&lt;code&gt;&amp;amp;a&lt;&#x2F;code&gt;的区别，我们先直接把它们打印出来看一下。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int a;
    printf(&amp;quot;%x\n%x\n&amp;quot;, a, &amp;amp;a); 
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;%x&lt;&#x2F;code&gt;的意思是按十六进制打印，运行我们应该会看到类似如下的结果：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;➜  .&amp;#x2F;format
0  # 这里值不一定，也可能不是0
f35ab98c # 这里的值也不一定，但是通常会很大，比如这个十六进制转成十进制就是‭3759417480‬
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里我们再进一步，做一个测试，首先我们改写程序，其次用系统工具查看一下系统调用。&lt;&#x2F;p&gt;
&lt;p&gt;先介绍一下我们用到的工具：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;echo&lt;&#x2F;code&gt;是能将输入原样输出的一个程序，如果下面是一个运行的例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;➜  echo 12341234
12341234
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;ltrace&lt;&#x2F;code&gt;是一个能跟踪库函数调用的工具，也就是说它能追踪到你程序调用的库里的类似&lt;code&gt;scanf&lt;&#x2F;code&gt;、&lt;code&gt;printf&lt;&#x2F;code&gt;这样的函数并且把调用函数的参数打印出来。&lt;&#x2F;p&gt;
&lt;p&gt;然后我们对下面这段程序使用上面写的工具，把&lt;code&gt;1234 1234&lt;&#x2F;code&gt;作为输入喂给程序。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int a;
    printf(&amp;quot;%d&amp;quot;, a);
    printf(&amp;quot;%d&amp;quot;, &amp;amp;a);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
    scanf(&amp;quot;%d&amp;quot;, a);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行结果如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;➜  echo &amp;quot;1234 1234&amp;quot; | ltrace .&amp;#x2F;format
printf(&amp;quot;%d&amp;quot;, 0)                                             = 1
printf(&amp;quot;%d&amp;quot;, -787805524)                                    = 10
__isoc99_scanf(0x7fa859609004, 0x7fffd10b0aac, 0x7fa85959d8c0, 0) = 1
__isoc99_scanf(0x7fa859609004, 1234, 0x7fa85959d8d0, 16 &amp;lt;no return ...&amp;gt;
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们可以看到，&lt;code&gt;printf&lt;&#x2F;code&gt;打印出了&lt;code&gt;a&lt;&#x2F;code&gt;的值，也就是&lt;code&gt;0&lt;&#x2F;code&gt;，同时第一个赋值没有出错，将&lt;code&gt;a&lt;&#x2F;code&gt;改为了1234，但是接下来的一行代码又出现了1234这个数字&lt;code&gt;__isoc99_scanf(0x7fa859609004, 1234, 0x7fa85959d8d0, 16 &amp;lt;no return ...&amp;gt;&lt;&#x2F;code&gt;。重复实验并且改变输入的数字，会发现这一行调用函数的第二个参数总是我们输入的第一个数字，也就是第一次给a赋值并成功的结果。&lt;&#x2F;p&gt;
&lt;p&gt;学过操作系统的同学或者对计算机组成有所了解的同学会知道，程序运行时的各种所需都是存储在内存里的，变量也不例外，而它们在内存里都是有个地址的。基于这些知识和刚才实验的结果，我们可以推测，&lt;code&gt;scanf(&amp;quot;%d&amp;quot;, a);&lt;&#x2F;code&gt;是将a的值认为是一个指针的地址并尝试向里面写入数据，但是a的默认值并不一定是一块给写数据的内存空间，这时候就引发了一个错误。&lt;&#x2F;p&gt;
&lt;p&gt;接下来让我们到&lt;code&gt;scanf&lt;&#x2F;code&gt;的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;scanf.3.html&quot;&gt;manual page&lt;&#x2F;a&gt;看看描述。&lt;&#x2F;p&gt;
&lt;p&gt;这里我把关键的两段截出来，其他部分对这个问题帮助不大所以就自己看了。重点看加粗部分&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   The scanf() family of functions scans input according to *format* as
   described below.  This format may contain *conversion specifications*;
   the results from such conversions, **if any, are stored in the
   locations pointed to by the *pointer* arguments that follow format**.
   Each pointer argument must be of a type that is appropriate for the
   value returned by the corresponding conversion specification.

   **If the number of conversion specifications in format exceeds the
   number of pointer arguments, the results are undefined.  If the
   number of pointer arguments exceeds the number of conversion
   specifications, then the excess pointer arguments are evaluated, but
   are otherwise ignored.**
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这里format指的是&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Printf_format_string&quot;&gt;格式化字符串&lt;&#x2F;a&gt;，简单来说就是printf&#x2F;printf的第一个参数，fscanf&#x2F;fprintf的第二个参数，而这个字符串里的conversion specifications（中文维基直译为转换说明）就是指指定类型的那个e&#x2F;p&#x2F;d&#x2F;x，比如%d中的d。同时从这里可能也就能理解为什么要叫printf&#x2F;scanf而不叫print&#x2F;scan，因为这是print format&#x2F;scan format的简写。顺便一提，格式化字符串还是一类漏洞的名称，有兴趣的话不妨搜索了解一下。&lt;&#x2F;p&gt;
&lt;p&gt;然后回到话题，看到第一处加粗的文字，也就是说，若里面有类似%d这样的参数，而且也有对应的参数（比如&lt;code&gt;scanf(&amp;quot;%d&amp;quot;, a)；&lt;&#x2F;code&gt;里的a就是%d对应的参数）scanf会按照格式读入数据（并将其转化为二进制表示），然后存入对应&lt;strong&gt;指针&lt;&#x2F;strong&gt;参数指向的地址。也就是说它把后面的参数认为是指针了。&lt;&#x2F;p&gt;
&lt;p&gt;这里C语言熟练的朋友就知道，局部自动(auto)变量定义时候不会隐式初始化，所以a的值是不确定的，把它直接给scanf用的结果大抵相当于向野指针指的地方写数据。所以段错误什么的很正常吧，&lt;&#x2F;p&gt;
&lt;p&gt;那么为什么下面这段代码不会出错呢？&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int a[1];
    printf(&amp;quot;%d&amp;quot;, a);
    printf(&amp;quot;%d&amp;quot;, &amp;amp;a);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
    scanf(&amp;quot;%d&amp;quot;, a);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;因为数组名是常量指针。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;肯定有认真听课的这样回答，但是很遗憾，不是的。数组名不是指针，但是它的确被转换成了指针。具体的内容可以搜索《说出来你们可能不信，但是数组名确实不是指针常量》。但是这个东西并不太重要，如果不当语言律师也没打算深度钻研C，也没有必要理解。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zai-han-shu-li-kai-bu-liao-da-shu-zu-ma&quot;&gt;在函数里开不了大数组吗？&lt;&#x2F;h1&gt;
&lt;p&gt;这里我们继续用代码做实验&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int a[524288];
    printf(&amp;quot;OK\n&amp;quot;);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译运行，程序多半并不能让我们看到&lt;code&gt;OK&lt;&#x2F;code&gt;，而是会出现和前面一样的情况，也就是段错误。（如果没出现就把这个数字翻几倍就能看到效果了）。&lt;&#x2F;p&gt;
&lt;p&gt;简单来说的话，函数中声明定义的非全局、非static，且没有使用&lt;code&gt;*alloc&lt;&#x2F;code&gt;、&lt;code&gt;new&lt;&#x2F;code&gt;产生的变量都会被放在栈上，栈的大小由编译选项决定，在我的电脑上大致就是能开500,000个int的大小。也可以在OJ上测试一下栈的大小，但同时并不建议在栈上开这么大，在ACM中还是全局的数组比较好用。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wo-kai-liao-yi-ge-hen-da-de-quan-ju-shu-zu-dan-shi-bian-yi-wu-fa-tong-guo-zhe-shi-wei-shi-yao&quot;&gt;我开了一个很大的全局数组，但是编译无法通过，这是为什么？&lt;&#x2F;h1&gt;
&lt;p&gt;编译器会阻止你开一个大小超过size_t表达范围的数组，也就是&lt;code&gt;sizeof&lt;&#x2F;code&gt;不会超过表达范围导致溢出的范围。而size_t是一个和平台相关的数据结构，在32位Linux机下，有以下结果：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;root@vultr:~# cat test.c
#include&amp;lt;stdio.h&amp;gt;
int a[10000000000];
int main()
{
        printf(&amp;quot;%d\n%d&amp;quot;,sizeof(size_t),sizeof(long long));
        return 0;
}

root@vultr:~# gcc test.c  -o test
test.c:2:5: error: size of array ‘a’ is too large
 int a[10000000000];
     ^
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而在64位Linux机下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;root@vultr:~# cat test.c
#include&amp;lt;stdio.h&amp;gt;
int a[10000000000];
int main()
{
                printf(&amp;quot;%d\n%d&amp;quot;,sizeof(size_t),sizeof(long long));
                        return 0;
}

root@vultr:~# gcc test.c -o test
root@vultr:~# cat test2.c
#include&amp;lt;stdio.h&amp;gt;
int a[10000000000000000000];
int main()
{
                printf(&amp;quot;%d\n%d&amp;quot;,sizeof(size_t),sizeof(long long));
                        return 0;
}

root@vultr:~# gcc test2.c -o test2
test2.c:2:5: error: size of array ‘a’ is too large
 int a[10000000000000000000];
     ^
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;wo-kai-liao-yi-ge-shao-xiao-yi-xie-de-quan-ju-shu-zu-wei-shi-yao-bian-yi-huan-shi-shi-bai-liao-er-qie-cuo-wu-de-yuan-yin-fei-chang-fu-za&quot;&gt;我开了一个稍小一些的全局数组，为什么编译还是失败了而且错误的原因非常复杂？&lt;&#x2F;h1&gt;
&lt;p&gt;把错误名单上下拉动找一下，通常能看到下图类似的东西，说明你遇到的正是我现在要说的这个问题：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;1573571964453.png&quot; alt=&quot;1573571964453&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;首先需要了解的知识是一个可执行文件的文件格式，在Windows上的是PE文件格式（包括&lt;code&gt;.exe&lt;&#x2F;code&gt;、&lt;code&gt;.dll文&lt;&#x2F;code&gt;件），Linux上则是ELF文件。不过这里不做深入解析，大家只需要知道这些文件的一个构成部分是各种节。&lt;&#x2F;p&gt;
&lt;p&gt;在Linux上使用&lt;code&gt;size&lt;&#x2F;code&gt;这个工具可以查看ELF文件的各个节的大小，这里我们准备三份代码，编译并使用size查看。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&amp;#x2F;&amp;#x2F; where_is_global.cpp
#include&amp;lt;stdio.h&amp;gt;
int a[1024];
int main()
{
    printf(&amp;quot;%OK&amp;quot;);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&amp;#x2F;&amp;#x2F; where_is_global2.cpp
#include&amp;lt;stdio.h&amp;gt;
int a[2048];
int main()
{
    printf(&amp;quot;%OK&amp;quot;);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&amp;#x2F;&amp;#x2F; where_is_global3.cpp
#include&amp;lt;stdio.h&amp;gt;
int a[1024] = {0};
int main()
{
    printf(&amp;quot;%OK&amp;quot;);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ size where_is_global
   text    data     bss     dec     hex filename
   1467     584    4128    6179    1823 where_is_global
$ size where_is_global2
   text    data     bss     dec     hex filename
   1467     584    8224   10275    2823 where_is_global2
$ size where_is_global3
   text    data     bss     dec     hex filename
   1467     584    4128    6179    1823 where_is_global3
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到区别仅在于bss所对应的数字，也就是说默认情况下，全局变量在编译后文件存放于.bss节，这也就是出现问题的原因。&lt;&#x2F;p&gt;
&lt;p&gt;默认情况下gcc对节的大小做了限制，如果超过的情况下就会出现这样的错误。但是这个是可以通过编译选项调整的，所以在不同的OJ上可能有不同的结果，在不同的环境下也不一定都能触发这个错误，下面是一份能在我的电脑上（Windows10 1903 Build, devcpp）触发的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;

int a[1000000000000000000L];

int main()
{
    printf(&amp;quot;%dK\n&amp;quot;,0);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;wo-kai-liao-yi-ge-hen-da-de-quan-ju-shu-zu-bing-qie-tong-guo-liao-bian-yi-ke-shi-wei-shi-yao-cheng-xu-yun-xing-yi-ran-reliao-deng-dai-geng-hao-de-da-an&quot;&gt;我开了一个很大的全局数组并且通过了编译，可是为什么程序运行依然RE了？（等待更好的答案）&lt;&#x2F;h1&gt;
&lt;p&gt;这里我也没有一个十分确定的答案，先直接给一个在我电脑上可以触发这样错误的程序&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;

static int a[1000000000000L];

int main()
{
    printf(&amp;quot;%dK\n&amp;quot;,a[1000000000L - 1]);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接下来我们深入到程序编译成的汇编代码里调试看一下，发现RE是出现在&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;1573577931809.png&quot; alt=&quot;1573579083511&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;后来找了办法确定了RAX里存放的是数组的地址，但是除此之外也不知道为什么会出这个错。&lt;&#x2F;p&gt;
&lt;p&gt;我理解来电脑不应该分配那么多内存，也就是分配阶段就应该出问题了，而不是在写东西的时候才有问题。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;和&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.yuki-nagato.com&#x2F;&quot;&gt;yuki nagato&lt;&#x2F;a&gt;讨论有了一个新的猜测&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;yuki nagato
关于这个问题，我觉得应该是因为未初始化的全局变量位于bss段，系统在程序开始执行时只是记录了它的大小，没有给它实际分配内存&lt;&#x2F;p&gt;
&lt;p&gt;yuki nagato
在首次访问的时候，系统会给它分配全零的页面，这时候会触发相关的错误&lt;&#x2F;p&gt;
&lt;p&gt;CSUwangj
嗯嗯，感觉你说的有道理&lt;&#x2F;p&gt;
&lt;p&gt;CSUwangj
这样子的话，我想想有没有办法验证&lt;&#x2F;p&gt;
&lt;p&gt;CSUwangj
似乎直接调试windows可能可以验证这个&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;但是由于本人调试Windows经验不足，验证期限无限期延长...欢迎大牛帮帮忙提提PR&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wei-shi-yao-yue-jie-hui-dao-zhi-re&quot;&gt;为什么越界会导致 RE？&lt;&#x2F;h1&gt;
&lt;p&gt;一句话回答就是，越界写会导致向不该写的地方写入数据。&lt;&#x2F;p&gt;
&lt;p&gt;详细展开的话，如果是对函数里的局部变量进行了越界写，那么可能会破坏程序运行时的调用栈，导致返回地址改变，这类情况也可以归结为栈溢出，而且这个名称同时也对应了历史上一类很有名的漏洞——&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-974510-1-1.html&quot;&gt;栈溢出漏洞&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;如果是对static变量、局部变量、使用new或者*alloc分配的变量进行越界写，因为它们分配在堆上，造成的问题也就是堆溢出，同样的，堆溢出也对应了&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ciphersaw.me&#x2F;ctf-wiki&#x2F;pwn&#x2F;linux&#x2F;heap&#x2F;heapoverflow_basic&#x2F;&quot;&gt;堆溢出漏洞&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;除此之外还有一种情况就是OJ的编译器对于越界做了特殊的判断，导致一旦出现越界写程序就会强制报错并结束，这样的情况虽然越界写没有对程序运行造成影响，也还是报了RE。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wei-shi-yao-you-shi-hou-yue-jie-bu-hui-re-dan-shi-hui-tle-wa&quot;&gt;为什么有时候越界不会 RE 但是会 TLE&#x2F;WA？&lt;&#x2F;h1&gt;
&lt;p&gt;在&lt;a href=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;#wei-shi-yao-zai-du-ru-de-shi-hou-bu-jia-jing-chang-hui-re-dan-shi-shu-zu-ming-bu-jia-jiu-mei-wen-ti&quot;&gt;第一个问题&lt;&#x2F;a&gt;中我们看到了，对程序进行的赋值操作其实也就是对对应内存的写入操作（不考虑利用寄存器优化的情况），同时我们可以用&lt;code&gt;printf(&amp;quot;%p&amp;quot;, &amp;amp;a);&lt;&#x2F;code&gt;这样的语句来查看变量a所在内存的地址。那么有以下代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;

int main()
{
    int a[16], b[16], t;
    printf(&amp;quot;%p %p %p\n&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;t);
    for(int i = 0; i &amp;lt; 34 ; ++ i){
        a[i] = i;
    }
    for(int i = 0; i &amp;lt; 16 ; ++ i){
        printf(&amp;quot;%d &amp;quot;, a[i]);
    }
    printf(&amp;quot;%d\n&amp;quot;, t);
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;已知第一行输出为&lt;code&gt;000000000062FD90 000000000062FDD0 000000000062FE14&lt;&#x2F;code&gt;，那么第二行输出是什么？（不要忘记考虑在我电脑上&lt;code&gt;sizeof(int)==4&lt;&#x2F;code&gt;）&lt;&#x2F;p&gt;
&lt;p&gt;答案是&lt;code&gt;16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 33&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;1573619928591.png&quot; alt=&quot;1573619950147&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;虽然变量在内存里的布局在C语言中是未定义的，但是通常来说它们根据情况（是否在同一函数、是否是全局&#x2F;static变量、是否通过new&#x2F;*alloc分配）占据一片空间的相邻位置。在这样的情况下越界写就会改变相邻变量的内容，于是导致WA（恰好改变了答案）、TLE（改变了循环用的计数器）也就不难理解了。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wo-zhi-ding-yi-guo-yi-ge-left-wei-shi-yao-bian-yi-qi-gao-su-wo-error-reference-to-left-is-ambiguous&quot;&gt;我只定义过一个 left，为什么编译器告诉我&lt;code&gt;[Error] reference to &#x27;left&#x27; is ambiguous&lt;&#x2F;code&gt;？&lt;&#x2F;h1&gt;
&lt;p&gt;如果你仔细查看报错信息，应该会看到类似&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;916    3    {PATH}    [Note] std::ios_base&amp;amp; std::left(std::ios_base&amp;amp;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;出现这种问题是因为引入的头文件中的变量，比如left这个是在&lt;code&gt;bits&#x2F;ios_base.h&lt;&#x2F;code&gt;里，而&lt;code&gt;algorithm&lt;&#x2F;code&gt;里有count这样的函数。&lt;&#x2F;p&gt;
&lt;p&gt;这些变量通常都在有两种方法可以解决，一是不要使用&lt;code&gt;using namespace std;&lt;&#x2F;code&gt;这个语句，另一个是不要用类似&lt;code&gt;left&lt;&#x2F;code&gt;, &lt;code&gt;count&lt;&#x2F;code&gt;这样的名称。从工程角度来说，第一个做法是比较合理的。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;error-ld-returned-1-exit-statusshi-shi-yao-cuo-wu&quot;&gt;[Error] ld returned 1 exit status是什么错误？&lt;&#x2F;h1&gt;
&lt;p&gt;一个C语言源代码到可执行文件之间需要经过预处理、编译、汇编、链接几个过程，ld(Linux)或者ld.exe(Windows)是GCC使用的链接器。&lt;&#x2F;p&gt;
&lt;p&gt;这个错误只是说明了链接器运行失败，但是具体的错误要向上找一两行才知道是为什么，这里举几个常见的例子：（欢迎补充）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-relocation-overflows-omitted-from-the-output&quot;&gt;additional relocation overflows omitted from the output&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;1573620431685.png&quot; alt=&quot;1573620431685&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;见&lt;a href=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;#wo-kai-liao-yi-ge-shao-xiao-yi-xie-de-quan-ju-shu-zu-wei-shi-yao-bian-yi-huan-shi-shi-bai-liao-er-qie-cuo-wu-de-yuan-yin-fei-chang-fu-za&quot;&gt;我开了一个稍小一些的全局数组，为什么编译还是失败了而且错误的原因非常复杂？&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;undefined-reference-to-winmain&quot;&gt;undefined reference to `WinMain&#x27;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;1573620523529.png&quot; alt=&quot;1573620523529&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;缺少main函数，通常是因为把main打成了mian&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cannot-open-output-file-zhe-li-shi-ge-lu-jing-permission-denied&quot;&gt;cannot open output file [这里是个路径]: Permission denied&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;acmzhong-yi-xie-chang-jian-de-wen-ti-ji-yuan-yin&#x2F;1573620621212.png&quot; alt=&quot;1573620621212&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;没有关闭正在运行的程序导致ld无法更新编译出来的.exe&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zong-shi-shuo-de-dui-zhan-shi-zhi-shi-yao-shi-shu-ju-jie-gou-li-de-dui-he-zhan-ma&quot;&gt;总是说的堆栈，是指什么？是数据结构里的堆和栈吗？&lt;&#x2F;h1&gt;
&lt;p&gt;这里指的是操作系统里的堆栈，和数据结构里的堆、栈不是一个东西。&lt;&#x2F;p&gt;
&lt;p&gt;这些前置知识能在《计算机组成原理》《操作系统》这样的书籍里找到，这里因为笔者学艺不精，不敢妄言，如果有大牛愿意贡献这部分的内容，欢迎在&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CSUwangj&#x2F;ACM_Weird_Problem&quot;&gt;repo&lt;&#x2F;a&gt;里提PR。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;can-kao-zi-liao&quot;&gt;参考资料&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;scanf manual page
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;scanf.3.html&quot;&gt;http:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;scanf.3.html&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;格式化字符串
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Printf_format_string&quot;&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Printf_format_string&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;如何调整GCC编译程序的默认栈大小
&lt;ul&gt;
&lt;li&gt;http:&#x2F;&#x2F;www.cplusplus.com&#x2F;forum&#x2F;general&#x2F;134645&#x2F;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Why is the maximum size of an array “too large”?
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;42575849&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;GCC compile option
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.6.0&#x2F;gcc&#x2F;i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;栈基础 &amp;amp; 栈溢出 &amp;amp; 栈溢出进阶
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-974510-1-1.html&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;0Day技术分析-4-堆溢出原理
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1083866&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>关于散列函数的一点思考</title>
		<published>2018-06-03T01:35:47+08:00</published>
		<updated>2020-08-07T01:48:37.612619+08:00</updated>
		<link rel="alternate" href="https://CSUwangj.github.io/guan-yu-san-lie-han-shu-de-yi-dian-si-kao/" type="text/html"/>
		<id>https://CSUwangj.github.io/guan-yu-san-lie-han-shu-de-yi-dian-si-kao/</id>
		<content type="html">&lt;p&gt;今天在ACM群灌水的时候因为一个题目引发了一些思考，题目是&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;qscoj.cn&#x2F;#&#x2F;contest&#x2F;show&#x2F;220&quot;&gt;比赛链接&lt;&#x2F;a&gt;的A题&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;其实题目很明显，3e4的字符串总量，1e3的字符串长度上限，样例就显示了有字母、数字、符号，就10M内存，用字典树妥妥炸了。&lt;&#x2F;p&gt;
&lt;p&gt;所以就哈希呗。&lt;&#x2F;p&gt;
&lt;p&gt;幸运的是STL里就有自带的hash函数，于是就水过去了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;#include &amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;
using namespace std;
int main()
{
	ios::sync_with_stdio(0);
	set&amp;lt;long long&amp;gt; m;
	hash&amp;lt;string&amp;gt; h;
	int n;
	string temp;
	cin&amp;gt;&amp;gt;n;
	while(n--){
		cin&amp;gt;&amp;gt;temp;
		m.insert(h(temp));
	}
	cout&amp;lt;&amp;lt;m.size()&amp;lt;&amp;lt;endl;
	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因为其实3e4这个字符串数量还是比较大的，在群里聊起了碰撞的问题，然后发现还是有丶东西，索性写一篇博文分析一下。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;san-lie-han-shu-jian-jie&quot;&gt;散列函数简介&lt;&#x2F;h2&gt;
&lt;p&gt;散列函数，也称哈希函数，是一种将任意大小数据映射到固定长度数字的单向函数。&lt;&#x2F;p&gt;
&lt;p&gt;散列函数常见于密码学的目的，随着密码学渗透到计算机的方方面面，因为其一些有用的特性也被用于ACM竞赛中。&lt;&#x2F;p&gt;
&lt;p&gt;通常来说，好的散列函数拥有以下几个特性：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;确定性。固定输入对应的散列值是固定的。&lt;&#x2F;li&gt;
&lt;li&gt;分布均一。优秀的散列函数会使得所有值可能出现的概率尽量一致，这也导出了后面引出的一些特性。&lt;&#x2F;li&gt;
&lt;li&gt;值域固定。比如&lt;code&gt;std::hash&lt;&#x2F;code&gt;的值域为size_t的可表示范围，SHA-1的值域为$[0,2^{160}-1]$。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;于是，用于密码学的散列函数经常有以下的特性：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;单向性。这里有两个含义，一方面来说既然任意大小的数据都被映射到固定范围的一些值上，那么必然是一个多对一的关系，这就是第一个单向的原因；第二个原因则是函数本身的算法经常会保证无法通过散列值计算原始数据可能的集合。&lt;&#x2F;li&gt;
&lt;li&gt;雪崩效应。一个比特的改变，可能就会引起值的大幅度变化（按CryptoExchane的说法，是一半以上的比特）。这样就很难通过碰撞发起攻击了。&lt;&#x2F;li&gt;
&lt;li&gt;抗碰撞性。这里具体又分为两种，一种为抗弱碰撞性，另一种为抗强碰撞性，分别对应第二原像攻击和碰撞攻击。
&lt;ol&gt;
&lt;li&gt;抗弱碰撞性。指对于某散列函数$H()$与任意给定的$x$，找到$y≠x$且$H(x)=H(y)$在计算上不可行。&lt;&#x2F;li&gt;
&lt;li&gt;抗强碰撞性。值对于某散列函数$H()$而言，找到$H(x)=H(y)$且$x≠y$这样的数对在计算上不可行。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;公开性。为了鉴别需求，常见的散列函数算法公开，这样任何能够编程的人都可以自己编程验证散列值。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;acmzhong-de-san-lie-han-shu&quot;&gt;ACM中的散列函数&lt;&#x2F;h2&gt;
&lt;p&gt;这里毕竟一个是我也退役了，没碰ACM有些时日，另一个我打ACM时也没有学得很深，所以这里的举例只能拿我们讲课的课件来粗糙地分析一下了，如果有误欢迎指出。&lt;&#x2F;p&gt;
&lt;p&gt;顺便ACM这比赛打过的同学就知道，不可能真写一个类似MD5这样的散列函数，ACM中的散列函数我通常用一句话概括：“又不是不能用。”&lt;&#x2F;p&gt;
&lt;p&gt;对于ACM当然是够用的，用其他地方就，再商量吧~&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhi-jie-mo-yu-fa&quot;&gt;直接模余法&lt;&#x2F;h3&gt;
&lt;p&gt;首先对于整数来说，最简单的方式就是模余法了，这也是很多&lt;strong&gt;题目&lt;&#x2F;strong&gt;处理大数的方式。模余法要尽量模上一个&lt;strong&gt;素数&lt;&#x2F;strong&gt;，这样会使得冲突的可能性降低。&lt;&#x2F;p&gt;
&lt;p&gt;但是选手在写题的时候通常不会直接模余，因为即便这样冲突降低，但是依然不小，而且会后续规避这样冲突的处理操作并不是很舒服。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhuan-huan-mo-yu-fa&quot;&gt;转换(模余)法&lt;&#x2F;h3&gt;
&lt;p&gt;这里请看这个例题&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;acm.hdu.edu.cn&#x2F;showproblem.php?pid=1496&quot;&gt;(&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;acm.hdu.edu.cn&#x2F;showproblem.php?pid=1496&quot;&gt;HDOJ-1496 Equations&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;acm.hdu.edu.cn&#x2F;showproblem.php?pid=1496&quot;&gt;)&lt;&#x2F;a&gt; &lt;&#x2F;p&gt;
&lt;p&gt;题意简单，就类似“百钱买百鸡”问题。&lt;&#x2F;p&gt;
&lt;p&gt;但是如果直接暴力地四重循环，那可就很嗨了……虽说一般一秒做$10^8$简单计算的确可以，但是这题的数据的确就是在超时的边缘。&lt;&#x2F;p&gt;
&lt;p&gt;正确的做法就是预处理两个变量所有可能对应值的相反数，然后进行查找。&lt;&#x2F;p&gt;
&lt;p&gt;但是如果直接搞，那就需要开$2×10^7$大小的数组，不仅在MLE的边缘，而且还有初始化TLE的风险。&lt;&#x2F;p&gt;
&lt;p&gt;所以这里就可以用散列了。具体讨论见&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;acm.hdu.edu.cn&#x2F;forum&#x2F;read.php?tid=3276&amp;amp;fpage=0&amp;amp;toread=&amp;amp;page=2&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;同样的，对于一个纯字母的字符串来说，也可以进行这样的转换。就是将一个字符串视为二十六进制的数字，然后求这个数字的十进制值，因为可能会溢出，就模上一个素数如$1000000007$这样的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zi-fu-chuan-hash-elfhash&quot;&gt;字符串HASH——ELFHASH&lt;&#x2F;h3&gt;
&lt;p&gt;这里直接放它的代码吧，十分简短。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&amp;#x2F;&amp;#x2F; ELF Hash Function  
unsigned int ELFHash(char *str)  
{  
    unsigned int hash = 0;  
    unsigned int x = 0;  
  
    while (*str)  
    {  
        hash = (hash &amp;lt;&amp;lt; 4) + (*str++);&amp;#x2F;&amp;#x2F;hash左移4位，把当前字符ASCII存入hash低四位。   
        if ((x = hash &amp;amp; 0xF0000000L) != 0)  
        {  
            &amp;#x2F;&amp;#x2F;如果最高的四位不为0，则说明字符多余7个，现在正在存第7个字符，如果不处理，再加下一个字符时，第一个字符会被移出，因此要有如下处理。  
            &amp;#x2F;&amp;#x2F;该处理，如果最高位为0，就会仅仅影响5-8位，否则会影响5-31位，因为C语言使用的算数移位  
            &amp;#x2F;&amp;#x2F;因为1-4位刚刚存储了新加入到字符，所以不能&amp;gt;&amp;gt;28  
            hash ^= (x &amp;gt;&amp;gt; 24);  
            &amp;#x2F;&amp;#x2F;上面这行代码并不会对X有影响，本身X和hash的高4位相同，下面这行代码&amp;amp;~即对28-31(高4位)位清零。  
            hash &amp;amp;= ~x;  
        }  
    }  
    &amp;#x2F;&amp;#x2F;返回一个符号位为0的数，即丢弃最高位，以免函数外产生影响。(我们可以考虑，如果只有字符，符号位不可能为负)  
    return (hash &amp;amp; 0x7FFFFFFF);  
}  
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个函数写起来十分简单。我把注释也复制过来了，就不多解释了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;san-lie-zhi-peng-zhuang-liao-zen-yao-ban&quot;&gt;散列值碰撞了，怎么办？&lt;&#x2F;h2&gt;
&lt;p&gt;扯了那么多前篇，终于到这篇博文真实目的了，不过估计会很短……&lt;&#x2F;p&gt;
&lt;p&gt;既然是散列函数，就要面对这个问题，一旦发生碰撞，很多问题就出来了，这里就简单分析一下针对散列函数的几个攻击吧。同时也会分析一下在ACM中散列函数的一点使用方法。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qiong-ju-gong-ji&quot;&gt;穷举攻击&lt;&#x2F;h3&gt;
&lt;p&gt;对于一个理想的散列函数来说，既然满足了上面的几个特性，穷举攻击需要的次数应该就是$\frac{值域}{2}$。&lt;&#x2F;p&gt;
&lt;p&gt;给你一个懂事的微笑。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sheng-ri-gong-ji&quot;&gt;生日攻击&lt;&#x2F;h3&gt;
&lt;p&gt;现在我们就尝试攻击散列函数的强抗碰撞性。这里以&lt;code&gt;std::hash&lt;&#x2F;code&gt;为例。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;CSUwangj.github.io&#x2F;guan-yu-san-lie-han-shu-de-yi-dian-si-kao&#x2F;1527960903963.png&quot; alt=&quot;cpp reference&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;基于散列函数的几个特性来说，我们得到值域内任意值的可能性都为$\frac1{2^{32}}$。那么，在计算不同的任意$n$个字符串候，这些散列值都不冲突的可能性就是$\frac{2^{32}-1}{2^{32}}×\frac{2^{32}-2}{2^{32}}×...×\frac{2^{32}-n+1}{2^{32}}$。&lt;&#x2F;p&gt;
&lt;p&gt;对于题目给的数据，使用下面Python代码可以计算得不发生冲突的概率为$0.9005311337474664$即发生错误的可能性为$0.0994688662525336$。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# a.py
a = 1 &amp;lt;&amp;lt; 32
s = 1
for i in range(0, 30000):
	s *= (a-i)&amp;#x2F;a
print(s)
#python a.py
#0.9005311337474664
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可见这个数字对于脸白的人来说是够了的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jiao-lian-wo-lian-hei-duo-zhong-san-lie-han-shu&quot;&gt;教练我脸黑——多重散列函数&lt;&#x2F;h3&gt;
&lt;p&gt;那么我们就要考虑找路子了，这里又有两条分支了：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;既然一个散列函数不行，那我就再来一个。之前是把字母字符串视为二十六进制数，那我就加个ELFHASH。这样做的好处是发生冲突的可能性稳定下降（变为两者发生冲突的乘积），坏处是编码难度上升。&lt;&#x2F;li&gt;
&lt;li&gt;加盐，加不同的盐值。但是这里要求散列函数是对块进行操作的。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;加盐，可以简单理解为在字符串前&#x2F;后面加上一个字符串，这样就可以使散列值发生变化。&lt;&#x2F;p&gt;
&lt;p&gt;对散列函数的要求是显而易见的，因为不论是二十六进制还是ELFHASH，只要之前字符串的散列值是同一个，那么在加盐后结果也不会发生改变。（块的大小对这里也会有影响，这里留给读者自行考虑）&lt;&#x2F;p&gt;
&lt;p&gt;对于&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;19411742&#x2F;what-is-the-default-hash-function-used-in-c-stdunordered-map?utm_medium=organic&amp;amp;utm_source=google_rich_qa&amp;amp;utm_campaign=google_rich_qa&quot;&gt;GCC&lt;&#x2F;a&gt;的&lt;code&gt;std::hash&lt;&#x2F;code&gt;来说，它用的是$MurmurHash Unaligned 2$，是一个分块大小为4的非密码学散列函数。&lt;&#x2F;p&gt;
&lt;p&gt;考虑理想状况，我们将多个盐值对应的不同散列值作为比对的标准，我们就能在一定程度上解决冲突，这里又能分出两条线。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jiang-bu-tong-san-lie-zhi-fang-zai-bu-tong-rong-qi-li&quot;&gt;将不同散列值放在不同容器里&lt;&#x2F;h4&gt;
&lt;p&gt;考虑这样的比对算法&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&amp;#x2F;&amp;#x2F;There is a bunch of set containers named s[0]&amp;#x2F;s[1]&amp;#x2F;etc
string str;
cin &amp;gt;&amp;gt;str;
temp = hash(str)
if(!s[0].count(temp)){
	s[0].insert(temp)
	count++
}else{
	temp = hash(str+&amp;quot;salt1&amp;quot;)
	if(!s[1].count(temp)){
		s[1].insert(temp)
		count++
    }else{
		&amp;#x2F;&amp;#x2F;etc
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那么可能会发生这样的问题，就是字符串s在第一次比对时和a串冲突，在第二次比对时又和b串冲突。&lt;&#x2F;p&gt;
&lt;p&gt;易知对于固定数量$n$的生日攻击来说，不发生冲突的概率$p$是一定的，假设多重散列函数就像我们所想的一样工作，那么该实验可以认为是一个成功率为$1-p$的伯努利实验。&lt;&#x2F;p&gt;
&lt;p&gt;在$m$重散列函数的情况下，均发生冲突的可能性是$P_0(m)=C_m^0(1-p)^m$，取这次题目的数据来说，两重散列函数发生冲突的概率为$0.009894055353564416$。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jiang-ge-san-lie-zhi-bao-zhuang-cheng-yi-ge-zheng-ti&quot;&gt;将各散列值包装成一个整体&lt;&#x2F;h4&gt;
&lt;p&gt;也就是说算法改为&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct hashv{
	size_t v[2];
};
set&amp;lt;hashv&amp;gt; s;

string str;
cin&amp;gt;&amp;gt;str;
hashv temp
temp.v[0] = hash(str)
temp.v[1] = hash(str+&amp;quot;salt&amp;quot;)
if(!s.count(temp)){
    s.insert(temp);
    count++;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;理想状态下，此时发生单次冲突的概率为两次散列均冲突的概率，即两者的乘积，也就是$2^{64}-2^{33}+1$&lt;&#x2F;p&gt;
&lt;p&gt;利用以下python代码计算得在题设情况下，不发生冲突的可能性为$0.9999999999999999999971601954045129840219384586382661991347799758614026869784477630643202473665079505271849114917935938025327598810920608449$ ，太强辣！&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from decimal import *
a = 1 &amp;lt;&amp;lt; 64 - 1&amp;lt;&amp;lt;33 +1
a = Decimal(str(a))
print(a)
s = Decimal(&amp;quot;1&amp;quot;)
getcontext().prec = 2000
for i in range(0, 30000):
	if not i% 1000:
		print(i)
	s *= (a-Decimal(str(i)))&amp;#x2F;a
print(s)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以发现，这样做以后是几何倍数降低发生碰撞的可能性了。&lt;&#x2F;p&gt;
&lt;p&gt;那么只有一个考虑了，就是这个结构体打算怎么写，不过这个问题就不是我操心的啦~&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hou-ji&quot;&gt;后记&lt;&#x2F;h2&gt;
&lt;p&gt;思考使我快乐，即便这篇文章很水嘻嘻嘻&lt;&#x2F;p&gt;
&lt;p&gt;睡觉去啦~&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
